cscope 15 $HOME\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\emblocks"               0000157375
	@C:\Users\Alexander\AppData\Roaming\energymicro\Device\EnergyMicro\EFM32GG\Source\GCC\startup_efm32gg.S

32 .
syax
 
	gunifd


33 .
ch
 
	gmv7
-
	gm


35 .
	gi
 .
	gack


36 .
	gign
 3

37 #ifde
__STACK_SIZE


38 .
equ
 
	gSck_Size
, 
	g__STACK_SIZE


40 .
equ
 
	gSck_Size
, 0x400

42 .
globl
 
	g__SckT


43 .
globl
 
__SckLim


44 
	g__SckLim
:

45 .
a
 
Sck_Size


46 .
size
 
__SckLim
, . - __StackLimit

47 
	g__SckT
:

48 .
size
 
__SckT
, . - 
	g__SckT


50 .
	gi
 .
	ghp


51 .
	gign
 3

52 #ifde
__HEAP_SIZE


53 .
equ
 
	gHp_Size
, 
	g__HEAP_SIZE


55 .
equ
 
	gHp_Size
, 0xC00

57 .
globl
 
	g__HpBa


58 .
globl
 
__HpLim


59 
	g__HpBa
:

60 .
Hp_Size


61 .
a
 
Hp_Size


62 .
dif


63 .
size
 
__HpBa
, . - __HeapBase

64 
	g__HpLim
:

65 .
size
 
__HpLim
, . - 
	g__HpLim


67 .
	gi
 .
	gi_ve


68 .
	gign
 8

69 .
globl
 
__i_ve


70 
	g__i_ve
:

71 .
__SckT


72 .
Ret_Hdr


73 .
NMI_Hdr


74 .
HdFau_Hdr


75 .
MemMage_Hdr


76 .
BusFau_Hdr


77 .
UgeFau_Hdr


78 .
Deu_Hdr


79 .
Deu_Hdr


80 .
Deu_Hdr


81 .
Deu_Hdr


82 .
SVC_Hdr


83 .
DebugM_Hdr


84 .
Deu_Hdr


85 .
PdSV_Hdr


86 .
SysTick_Hdr


89 .
DMA_IRQHdr


90 .
GPIO_EVEN_IRQHdr


91 .
TIMER0_IRQHdr


92 .
USART0_RX_IRQHdr


93 .
USART0_TX_IRQHdr


94 .
USB_IRQHdr


95 .
ACMP0_IRQHdr


96 .
ADC0_IRQHdr


97 .
DAC0_IRQHdr


98 .
I2C0_IRQHdr


99 .
I2C1_IRQHdr


100 .
GPIO_ODD_IRQHdr


101 .
TIMER1_IRQHdr


102 .
TIMER2_IRQHdr


103 .
TIMER3_IRQHdr


104 .
USART1_RX_IRQHdr


105 .
USART1_TX_IRQHdr


106 .
LESENSE_IRQHdr


107 .
USART2_RX_IRQHdr


108 .
USART2_TX_IRQHdr


109 .
UART0_RX_IRQHdr


110 .
UART0_TX_IRQHdr


111 .
UART1_RX_IRQHdr


112 .
UART1_TX_IRQHdr


113 .
LEUART0_IRQHdr


114 .
LEUART1_IRQHdr


115 .
LETIMER0_IRQHdr


116 .
PCNT0_IRQHdr


117 .
PCNT1_IRQHdr


118 .
PCNT2_IRQHdr


119 .
RTC_IRQHdr


120 .
BURTC_IRQHdr


121 .
CMU_IRQHdr


122 .
VCMP_IRQHdr


123 .
LCD_IRQHdr


124 .
MSC_IRQHdr


125 .
AES_IRQHdr


126 .
EBI_IRQHdr


127 .
EMU_IRQHdr


130 .
size
 
__i_ve
, . - 
	g__i_ve


132 .
	gxt


133 .
	gthumb


134 .
	gthumb_func


135 .
	gign
 2

136 .
globl
 
	gRet_Hdr


137 .
ty
 
	gRet_Hdr
, %
funi


138 
	gRet_Hdr
:

145 #ide
__NO_SYSTEM_INIT


146 
ldr
 
r0
, =
SyemIn


147 
blx
 
r0


149 
ldr
 
r1
, =
__ext


150 
ldr
 
r2
, =
__da_t__


151 
ldr
 
r3
, =
__da_d__


157 .
ash_to_m_lo
:

158 
cmp
 
r2
, 
r3


159 

 



160 
ldt
 
	gr0
, [
r1
], #4

161 
t
 
	gr0
, [
r2
], #4

162 
	gb
 .
	gash_to_m_lo


164 
subs
 
	gr3
, 
r2


165 
	gb
 .
	gash_to_m_lo_d


166 .
	gash_to_m_lo
:

167 
subs
 
r3
, #4

168 
ldr
 
	gr0
, [
r1
, 
r3
]

169 
r
 
	gr0
, [
r2
, 
r3
]

170 
	gbgt
 .
	gash_to_m_lo


171 .
	gash_to_m_lo_d
:

174 
ldr
 
r0
, =
_t


175 
bx
 
r0


176 .
po


177 .
size
 
Ret_Hdr
, . - 
	gRet_Hdr


182 .
mao
 
def_q_hdr
 
	ghdr_me


183 .
	gign
 1

184 .
	gthumb_func


185 .
	gwk
 \
	ghdr_me


186 .
	gty
 \
	ghdr_me
, %
	gfuni


187 \
	ghdr_me
:

188 
b
 .

189 .
size
 \
hdr_me
, . - \
	ghdr_me


190 .
dm


192 
def_q_hdr
 
Deu_Hdr


194 
def_q_hdr
 
NMI_Hdr


195 
def_q_hdr
 
HdFau_Hdr


196 
def_q_hdr
 
MemMage_Hdr


197 
def_q_hdr
 
BusFau_Hdr


198 
def_q_hdr
 
UgeFau_Hdr


199 
def_q_hdr
 
SVC_Hdr


200 
def_q_hdr
 
DebugM_Hdr


201 
def_q_hdr
 
PdSV_Hdr


202 
def_q_hdr
 
SysTick_Hdr


204 
def_q_hdr
 
DMA_IRQHdr


205 
def_q_hdr
 
GPIO_EVEN_IRQHdr


206 
def_q_hdr
 
TIMER0_IRQHdr


207 
def_q_hdr
 
USART0_RX_IRQHdr


208 
def_q_hdr
 
USART0_TX_IRQHdr


209 
def_q_hdr
 
USB_IRQHdr


210 
def_q_hdr
 
ACMP0_IRQHdr


211 
def_q_hdr
 
ADC0_IRQHdr


212 
def_q_hdr
 
DAC0_IRQHdr


213 
def_q_hdr
 
I2C0_IRQHdr


214 
def_q_hdr
 
I2C1_IRQHdr


215 
def_q_hdr
 
GPIO_ODD_IRQHdr


216 
def_q_hdr
 
TIMER1_IRQHdr


217 
def_q_hdr
 
TIMER2_IRQHdr


218 
def_q_hdr
 
TIMER3_IRQHdr


219 
def_q_hdr
 
USART1_RX_IRQHdr


220 
def_q_hdr
 
USART1_TX_IRQHdr


221 
def_q_hdr
 
LESENSE_IRQHdr


222 
def_q_hdr
 
USART2_RX_IRQHdr


223 
def_q_hdr
 
USART2_TX_IRQHdr


224 
def_q_hdr
 
UART0_RX_IRQHdr


225 
def_q_hdr
 
UART0_TX_IRQHdr


226 
def_q_hdr
 
UART1_RX_IRQHdr


227 
def_q_hdr
 
UART1_TX_IRQHdr


228 
def_q_hdr
 
LEUART0_IRQHdr


229 
def_q_hdr
 
LEUART1_IRQHdr


230 
def_q_hdr
 
LETIMER0_IRQHdr


231 
def_q_hdr
 
PCNT0_IRQHdr


232 
def_q_hdr
 
PCNT1_IRQHdr


233 
def_q_hdr
 
PCNT2_IRQHdr


234 
def_q_hdr
 
RTC_IRQHdr


235 
def_q_hdr
 
BURTC_IRQHdr


236 
def_q_hdr
 
CMU_IRQHdr


237 
def_q_hdr
 
VCMP_IRQHdr


238 
def_q_hdr
 
LCD_IRQHdr


239 
def_q_hdr
 
MSC_IRQHdr


240 
def_q_hdr
 
AES_IRQHdr


241 
def_q_hdr
 
EBI_IRQHdr


242 
def_q_hdr
 
	gEMU_IRQHdr


245 .
	gd


	@C:\Users\Alexander\AppData\Roaming\energymicro\Device\EnergyMicro\EFM32GG\Source\system_efm32gg.c

34 
	~<dt.h
>

35 
	~"em_devi.h
"

42 
	#EFM32_LFRCO_FREQ
 (32768UL)

	)

43 
	#EFM32_ULFRCO_FREQ
 (1000UL)

	)

57 #ide
EFM32_HFXO_FREQ


58 #ifde
_EFM32_GIANT_FAMILY


59 
	#EFM32_HFXO_FREQ
 (48000000UL)

	)

61 
	#EFM32_HFXO_FREQ
 (32000000UL)

	)

65 #i(
EFM32_HFXO_FREQ
 > 0)

68 
ut32_t
 
	gSyemHFXOClock
 = 
EFM32_HFXO_FREQ
;

72 #ide
EFM32_LFXO_FREQ


73 
	#EFM32_LFXO_FREQ
 (
EFM32_LFRCO_FREQ
)

	)

76 #i(
EFM32_LFXO_FREQ
 > 0)

79 
ut32_t
 
	gSyemLFXOClock
 = 
EFM32_LFXO_FREQ
;

84 
__STATIC_INLINE
 
ut8_t
 
	$GProdRev
()

86  ((
DEVINFO
->
PART
 & 
_DEVINFO_PART_PROD_REV_MASK
)

87 >> 
_DEVINFO_PART_PROD_REV_SHIFT
);

88 
	}
}

101 
ut32_t
 
	gSyemCeClock
;

124 
ut32_t
 
	$SyemCeClockG
()

126 
ut32_t
 
t
;

128 
t
 = 
	`SyemHFClockG
();

129 #i
	`defed
 (
_EFM32_GIANT_FAMILY
)

131 
t
 = / (1 + ((
CMU
->
CTRL
 & 
_CMU_CTRL_HFCLKDIV_MASK
)>>
_CMU_CTRL_HFCLKDIV_SHIFT
));

133 
t
 >>(
CMU
->
HFCORECLKDIV
 & 
_CMU_HFCORECLKDIV_HFCORECLKDIV_MASK
) >>

134 
_CMU_HFCORECLKDIV_HFCORECLKDIV_SHIFT
;

137 
SyemCeClock
 = 
t
;

139  
t
;

140 
	}
}

153 
ut32_t
 
	$SyemHFClockG
()

155 
ut32_t
 
t
;

157 
CMU
->
STATUS
 & (
CMU_STATUS_HFRCOSEL
 | 
CMU_STATUS_HFXOSEL
 |

158 
CMU_STATUS_LFRCOSEL
 | 
CMU_STATUS_LFXOSEL
))

160 
CMU_STATUS_LFXOSEL
:

161 #i(
EFM32_LFXO_FREQ
 > 0)

162 
t
 = 
SyemLFXOClock
;

166 
t
 = 0;

170 
CMU_STATUS_LFRCOSEL
:

171 
t
 = 
EFM32_LFRCO_FREQ
;

174 
CMU_STATUS_HFXOSEL
:

175 #i(
EFM32_HFXO_FREQ
 > 0)

176 
t
 = 
SyemHFXOClock
;

180 
t
 = 0;

185 
CMU
->
HFRCOCTRL
 & 
_CMU_HFRCOCTRL_BAND_MASK
)

187 
CMU_HFRCOCTRL_BAND_28MHZ
:

188 
t
 = 28000000;

191 
CMU_HFRCOCTRL_BAND_21MHZ
:

192 
t
 = 21000000;

195 
CMU_HFRCOCTRL_BAND_14MHZ
:

196 
t
 = 14000000;

199 
CMU_HFRCOCTRL_BAND_11MHZ
:

200 
t
 = 11000000;

203 
CMU_HFRCOCTRL_BAND_7MHZ
:

204 i
	`GProdRev
() >= 19 )

205 
t
 = 6600000;

207 
t
 = 7000000;

210 
CMU_HFRCOCTRL_BAND_1MHZ
:

211 i
	`GProdRev
() >= 19 )

212 
t
 = 1200000;

214 
t
 = 1000000;

218 
t
 = 0;

224  
t
;

225 
	}
}

238 
ut32_t
 
	$SyemHFXOClockG
()

241 #i(
EFM32_HFXO_FREQ
 > 0)

242  
SyemHFXOClock
;

246 
	}
}

264 
	$SyemHFXOClockS
(
ut32_t
 
eq
)

267 #i(
EFM32_HFXO_FREQ
 > 0)

268 
SyemHFXOClock
 = 
eq
;

271 i(
CMU
->
STATUS
 & 
CMU_STATUS_HFXOSEL
)

274 
	`SyemCeClockG
();

277 ()
eq
;

279 
	}
}

294 
	$SyemIn
()

296 
	}
}

309 
ut32_t
 
	$SyemLFRCOClockG
()

314  
EFM32_LFRCO_FREQ
;

315 
	}
}

328 
ut32_t
 
	$SyemULFRCOClockG
()

331  
EFM32_ULFRCO_FREQ
;

332 
	}
}

345 
ut32_t
 
	$SyemLFXOClockG
()

348 #i(
EFM32_LFXO_FREQ
 > 0)

349  
SyemLFXOClock
;

353 
	}
}

371 
	$SyemLFXOClockS
(
ut32_t
 
eq
)

374 #i(
EFM32_LFXO_FREQ
 > 0)

375 
SyemLFXOClock
 = 
eq
;

378 i(
CMU
->
STATUS
 & 
CMU_STATUS_LFXOSEL
)

381 
	`SyemCeClockG
();

384 ()
eq
;

386 
	}
}

	@C:\Users\Alexander\AppData\Roaming\energymicro\emlib\src\em_assert.c

33 
	~"em_as.h
"

35 #i
defed
(
DEBUG_EFM
)

59 
	$asEFM
(cڡ *
fe
, 
le
)

61 ()
fe
;

62 ()
le
;

66 
	}
}

	@C:\Users\Alexander\AppData\Roaming\energymicro\emlib\src\em_cmu.c

33 
	~"em_devi.h
"

34 
	~"em_cmu.h
"

35 
	~"em_as.h
"

36 
	~"em_bbd.h
"

37 
	~"em_emu.h
"

57 
	#CMU_MAX_FREQ_0WS
 16000000

	)

59 
	#CMU_MAX_FREQ_1WS
 32000000

	)

61 
	#CMU_MAX_FREQ_HFLE
 32000000

	)

64 
	#CMU_LFA
 0

	)

67 
	#CMU_LFB
 1

	)

82 
	$CMU_FshWaSMax
()

84 
ut32_t
 
cfg
;

86 
cfg
 = 
MSC
->
READCTRL
;

88 
cfg
 & 
_MSC_READCTRL_MODE_MASK
)

90 
MSC_READCTRL_MODE_WS1
:

91 
MSC_READCTRL_MODE_WS0
:

92 #i
	`defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

93 
MSC_READCTRL_MODE_WS2
:

94 
cfg
 = (cfg & ~
_MSC_READCTRL_MODE_MASK
| 
MSC_READCTRL_MODE_WS2
;

96 
cfg
 = (cfg & ~
_MSC_READCTRL_MODE_MASK
| 
MSC_READCTRL_MODE_WS1
;

99 
MSC_READCTRL_MODE_WS1SCBTP
:

100 
MSC_READCTRL_MODE_WS0SCBTP
:

101 #i
	`defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

102 
MSC_READCTRL_MODE_WS2SCBTP
:

103 
cfg
 = (cfg & ~
_MSC_READCTRL_MODE_MASK
| 
MSC_READCTRL_MODE_WS2SCBTP
;

105 
cfg
 = (cfg & ~
_MSC_READCTRL_MODE_MASK
| 
MSC_READCTRL_MODE_WS1SCBTP
;

109 
MSC
->
READCTRL
 = 
cfg
;

110 
	}
}

119 
__STATIC_INLINE
 
ut32_t
 
	$CMU_DivToLog2
(
CMU_ClkDiv_TyDef
 
div
)

121 
ut32_t
 
log2
;

124 
	`EFM_ASSERT
((
div
>0) && (div <= 32768));

127 
log2
 = (31 - 
	`__CLZ
(
div
));

129  
log2
;

130 
	}
}

138 
__STATIC_INLINE
 
ut32_t
 
	$CMU_Log2ToDiv
(
ut32_t
 
log2
)

140  1<<
log2
;

141 
	}
}

152 
	$CMU_FshWaSCڌ
(
ut32_t
 
hfcek
)

154 
ut32_t
 
cfg
;

156 
cfg
 = 
MSC
->
READCTRL
;

158 #i
	`defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

159 i(
hfcek
 > 
CMU_MAX_FREQ_1WS
)

161 
cfg
 & 
_MSC_READCTRL_MODE_MASK
)

163 
MSC_READCTRL_MODE_WS0SCBTP
:

164 
MSC_READCTRL_MODE_WS1SCBTP
:

165 
cfg
 = (cfg & ~
_MSC_READCTRL_MODE_MASK
| 
MSC_READCTRL_MODE_WS2SCBTP
;

167 
MSC_READCTRL_MODE_WS0
:

168 
MSC_READCTRL_MODE_WS1
:

170 
cfg
 = (cfg & ~
_MSC_READCTRL_MODE_MASK
| 
MSC_READCTRL_MODE_WS2
;

176 i((
hfcek
 > 
CMU_MAX_FREQ_0WS
&& (hfcek <
CMU_MAX_FREQ_1WS
))

178 
cfg
 & 
_MSC_READCTRL_MODE_MASK
)

180 #i
	`defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

181 
MSC_READCTRL_MODE_WS2SCBTP
:

183 
MSC_READCTRL_MODE_WS0SCBTP
:

184 
MSC_READCTRL_MODE_WS1SCBTP
:

185 
cfg
 = (cfg & ~
_MSC_READCTRL_MODE_MASK
| 
MSC_READCTRL_MODE_WS1SCBTP
;

189 
cfg
 = (cfg & ~
_MSC_READCTRL_MODE_MASK
| 
MSC_READCTRL_MODE_WS1
;

194 i(
hfcek
 <
CMU_MAX_FREQ_0WS
)

196 
cfg
 & 
_MSC_READCTRL_MODE_MASK
)

198 #i
	`defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

199 
MSC_READCTRL_MODE_WS2SCBTP
:

201 
MSC_READCTRL_MODE_WS1SCBTP
:

202 
MSC_READCTRL_MODE_WS0SCBTP
:

203 
cfg
 = (cfg & ~
_MSC_READCTRL_MODE_MASK
| 
MSC_READCTRL_MODE_WS0SCBTP
;

207 
cfg
 = (cfg & ~
_MSC_READCTRL_MODE_MASK
| 
MSC_READCTRL_MODE_WS0
;

212 
MSC
->
READCTRL
 = 
cfg
;

213 
	}
}

216 #i
defed
(
USB_PRESENT
)

224 
ut32_t
 
	$CMU_USBCClkG
()

226 
ut32_t
 
t
;

227 
CMU_Se_TyDef
 
k
;

230 
k
 = 
	`CMU_ClockSeG
(
cmuClock_USBC
);

232 
k
)

234 
cmuSe_LFXO
:

235 
t
 = 
	`SyemLFXOClockG
();

237 
cmuSe_LFRCO
:

238 
t
 = 
	`SyemLFRCOClockG
();

240 
cmuSe_HFCLK
:

241 
t
 = 
	`SyemHFClockG
();

245 
t
 = 0;

248  
t
;

249 
	}
}

261 
ut32_t
 
	$CMU_AUXClkG
()

263 
ut32_t
 
t
;

265 #i
	`defed
 (
_EFM32_GECKO_FAMILY
)

267 
t
 = 14000000;

269 
CMU
->
AUXHFRCOCTRL
 & 
_CMU_AUXHFRCOCTRL_BAND_MASK
)

271 
CMU_AUXHFRCOCTRL_BAND_1MHZ
:

272 
t
 = 1000000;

274 
CMU_AUXHFRCOCTRL_BAND_7MHZ
:

275 
t
 = 7000000;

277 
CMU_AUXHFRCOCTRL_BAND_11MHZ
:

278 
t
 = 11000000;

280 
CMU_AUXHFRCOCTRL_BAND_14MHZ
:

281 
t
 = 14000000;

283 
CMU_AUXHFRCOCTRL_BAND_21MHZ
:

284 
t
 = 21000000;

286 
CMU_AUXHFRCOCTRL_BAND_28MHZ
:

287 
t
 = 28000000;

290 
t
 = 0;

294  
t
;

295 
	}
}

305 
ut32_t
 
	$CMU_DBGClkG
()

307 
ut32_t
 
t
;

308 
CMU_Se_TyDef
 
k
;

311 
k
 = 
	`CMU_ClockSeG
(
cmuClock_DBG
);

313 
k
)

315 
cmuSe_HFCLK
:

316 
t
 = 
	`SyemHFClockG
();

317 #i
	`defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

319 
t
 = / (1 + ((
CMU
->
CTRL
 & 
_CMU_CTRL_HFCLKDIV_MASK
) >>

320 
_CMU_CTRL_HFCLKDIV_SHIFT
));

324 
cmuSe_AUXHFRCO
:

325 
t
 = 
	`CMU_AUXClkG
();

329 
	`EFM_ASSERT
(0);

330 
t
 = 0;

333  
t
;

334 
	}
}

348 
ut32_t
 
	$CMU_LFClkG
(
lfClkBnch
)

350 
ut32_t
 
t
;

352 
	`EFM_ASSERT
(
lfClkBnch
 =
CMU_LFA
 ||fClkBnch =
CMU_LFB
);

354 (
CMU
->
LFCLKSEL
 >> (
lfClkBnch
 * 2)) & 0x3)

356 
_CMU_LFCLKSEL_LFA_LFRCO
:

357 
t
 = 
	`SyemLFRCOClockG
();

360 
_CMU_LFCLKSEL_LFA_LFXO
:

361 
t
 = 
	`SyemLFXOClockG
();

364 
_CMU_LFCLKSEL_LFA_HFCORECLKLEDIV2
:

365 #i
	`defed
 (
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

367 if(((
CMU
->
HFCORECLKDIV
 & 
_CMU_HFCORECLKDIV_HFCORECLKLEDIV_MASK
=
CMU_HFCORECLKDIV_HFCORECLKLEDIV_DIV4
)||

368 (
CMU
->
CTRL
 & 
CMU_CTRL_HFLE
))

370 
t
 = 
	`SyemCeClockG
() / 4;

374 
t
 = 
	`SyemCeClockG
() / 2;

377 
t
 = 
	`SyemCeClockG
() / 2;

381 
_CMU_LFCLKSEL_LFA_DISABLED
:

382 #i
	`defed
 (
_EFM32_GIANT_FAMILY
|| defed (
_EFM32_TINY_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

384 if(
CMU
->
LFCLKSEL
 >> (
_CMU_LFCLKSEL_LFAE_SHIFT
 + 
lfClkBnch
 * 4))

386 
t
 = 
	`SyemULFRCOClockG
();

390 
t
 = 0;

393 
t
 = 0;

398 
t
 = 0;

402  
t
;

403 
	}
}

414 
__STATIC_INLINE
 
	$CMU_Sync
(
ut32_t
 
mask
)

418 i(
CMU
->
FREEZE
 & 
CMU_FREEZE_REGFREEZE
)

423 
CMU
->
SYNCBUSY
 & 
mask
)

425 
	}
}

456 
ut32_t
 
	$CMU_Cib
(
ut32_t
 
HFCyes
, 
CMU_Osc_TyDef
 
f
)

458 
	`EFM_ASSERT
(
HFCyes
 <(
_CMU_CALCNT_CALCNT_MASK
 >> 
_CMU_CALCNT_CALCNT_SHIFT
));

461 
f
)

463 
cmuOsc_LFXO
:

464 
CMU
->
CALCTRL
 = 
CMU_CALCTRL_UPSEL_LFXO
;

467 
cmuOsc_LFRCO
:

468 
CMU
->
CALCTRL
 = 
CMU_CALCTRL_UPSEL_LFRCO
;

471 
cmuOsc_HFXO
:

472 
CMU
->
CALCTRL
 = 
CMU_CALCTRL_UPSEL_HFXO
;

475 
cmuOsc_HFRCO
:

476 
CMU
->
CALCTRL
 = 
CMU_CALCTRL_UPSEL_HFRCO
;

479 
cmuOsc_AUXHFRCO
:

480 
CMU
->
CALCTRL
 = 
CMU_CALCTRL_UPSEL_AUXHFRCO
;

484 
	`EFM_ASSERT
(0);

489 
CMU
->
CALCNT
 = 
HFCyes
;

492 
CMU
->
CMD
 = 
CMU_CMD_CALSTART
;

495 
CMU
->
STATUS
 & 
CMU_STATUS_CALBSY
)

498  
CMU
->
CALCNT
;

499 
	}
}

502 #i
defed
 (
_EFM32_TINY_FAMILY
|| defed(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

529 
	$CMU_CibCfig
(
ut32_t
 
downCyes
, 
CMU_Osc_TyDef
 
downS
,

530 
CMU_Osc_TyDef
 
upS
)

533 
ut32_t
 
lCl
 = 
CMU
->
CALCTRL
 & ~(
_CMU_CALCTRL_UPSEL_MASK
 | 
_CMU_CALCTRL_DOWNSEL_MASK
);

536 
	`EFM_ASSERT
(
downCyes
 <(
_CMU_CALCNT_CALCNT_MASK
 >> 
_CMU_CALCNT_CALCNT_SHIFT
));

539 
downS
)

541 
cmuOsc_LFXO
:

542 
lCl
 |
CMU_CALCTRL_DOWNSEL_LFXO
;

545 
cmuOsc_LFRCO
:

546 
lCl
 |
CMU_CALCTRL_DOWNSEL_LFRCO
;

549 
cmuOsc_HFXO
:

550 
lCl
 |
CMU_CALCTRL_DOWNSEL_HFXO
;

553 
cmuOsc_HFRCO
:

554 
lCl
 |
CMU_CALCTRL_DOWNSEL_HFRCO
;

557 
cmuOsc_AUXHFRCO
:

558 
lCl
 |
CMU_CALCTRL_DOWNSEL_AUXHFRCO
;

562 
	`EFM_ASSERT
(0);

567 
CMU
->
CALCNT
 = 
downCyes
;

570 
upS
)

572 
cmuOsc_LFXO
:

573 
lCl
 |
CMU_CALCTRL_UPSEL_LFXO
;

576 
cmuOsc_LFRCO
:

577 
lCl
 |
CMU_CALCTRL_UPSEL_LFRCO
;

580 
cmuOsc_HFXO
:

581 
lCl
 |
CMU_CALCTRL_UPSEL_HFXO
;

584 
cmuOsc_HFRCO
:

585 
lCl
 |
CMU_CALCTRL_UPSEL_HFRCO
;

588 
cmuOsc_AUXHFRCO
:

589 
lCl
 |
CMU_CALCTRL_UPSEL_AUXHFRCO
;

593 
	`EFM_ASSERT
(0);

597 
CMU
->
CALCTRL
 = 
lCl
;

598 
	}
}

614 
CMU_ClkDiv_TyDef
 
	$CMU_ClockDivG
(
CMU_Clock_TyDef
 
ock
)

616 
ut32_t
 
divReg
;

617 
CMU_ClkDiv_TyDef
 
t
;

620 
divReg
 = (
ock
 >> 
CMU_DIV_REG_POS
& 
CMU_DIV_REG_MASK
;

622 
divReg
)

624 #i
	`defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

625 
CMU_HFCLKDIV_REG
:

626 
t
 = 1 + ((
CMU
->
CTRL
 & 
_CMU_CTRL_HFCLKDIV_MASK
) >>

627 
_CMU_CTRL_HFCLKDIV_SHIFT
);

631 
CMU_HFPERCLKDIV_REG
:

632 
t
 = (
CMU_ClkDiv_TyDef
)((
CMU
->
HFPERCLKDIV
 &

633 
_CMU_HFPERCLKDIV_HFPERCLKDIV_MASK
) >>

634 
_CMU_HFPERCLKDIV_HFPERCLKDIV_SHIFT
);

635 
t
 = 
	`CMU_Log2ToDiv
(ret);

638 
CMU_HFCORECLKDIV_REG
:

639 
t
 = (
CMU_ClkDiv_TyDef
)((
CMU
->
HFCORECLKDIV
 &

640 
_CMU_HFCORECLKDIV_HFCORECLKDIV_MASK
) >>

641 
_CMU_HFCORECLKDIV_HFCORECLKDIV_SHIFT
);

642 
t
 = 
	`CMU_Log2ToDiv
(ret);

645 
CMU_LFAPRESC0_REG
:

646 
ock
)

648 
cmuClock_RTC
:

649 
t
 = (
CMU_ClkDiv_TyDef
)(((
CMU
->
LFAPRESC0
 & 
_CMU_LFAPRESC0_RTC_MASK
) >>

650 
_CMU_LFAPRESC0_RTC_SHIFT
));

651 
t
 = 
	`CMU_Log2ToDiv
(ret);

654 #i
	`defed
(
_CMU_LFAPRESC0_LETIMER0_MASK
)

655 
cmuClock_LETIMER0
:

656 
t
 = (
CMU_ClkDiv_TyDef
)(((
CMU
->
LFAPRESC0
 & 
_CMU_LFAPRESC0_LETIMER0_MASK
) >>

657 
_CMU_LFAPRESC0_LETIMER0_SHIFT
));

658 
t
 = 
	`CMU_Log2ToDiv
(ret);

662 #i
	`defed
(
_CMU_LFAPRESC0_LCD_MASK
)

663 
cmuClock_LCDe
:

664 
t
 = (
CMU_ClkDiv_TyDef
)(((
CMU
->
LFAPRESC0
 & 
_CMU_LFAPRESC0_LCD_MASK
) >>

665 
_CMU_LFAPRESC0_LCD_SHIFT
+ 
	`CMU_DivToLog2
(
cmuClkDiv_16
));

666 
t
 = 
	`CMU_Log2ToDiv
(ret);

670 #i
	`defed
(
_CMU_LFAPRESC0_LESENSE_MASK
)

671 
cmuClock_LESENSE
:

672 
t
 = (
CMU_ClkDiv_TyDef
)(((
CMU
->
LFAPRESC0
 & 
_CMU_LFAPRESC0_LESENSE_MASK
) >>

673 
_CMU_LFAPRESC0_LESENSE_SHIFT
));

674 
t
 = 
	`CMU_Log2ToDiv
(ret);

679 
	`EFM_ASSERT
(0);

680 
t
 = 
cmuClkDiv_1
;

685 
CMU_LFBPRESC0_REG
:

686 
ock
)

688 #i
	`defed
(
_CMU_LFBPRESC0_LEUART0_MASK
)

689 
cmuClock_LEUART0
:

690 
t
 = (
CMU_ClkDiv_TyDef
)(((
CMU
->
LFBPRESC0
 & 
_CMU_LFBPRESC0_LEUART0_MASK
) >>

691 
_CMU_LFBPRESC0_LEUART0_SHIFT
));

692 
t
 = 
	`CMU_Log2ToDiv
(ret);

696 #i
	`defed
(
_CMU_LFBPRESC0_LEUART1_MASK
)

697 
cmuClock_LEUART1
:

698 
t
 = (
CMU_ClkDiv_TyDef
)(((
CMU
->
LFBPRESC0
 & 
_CMU_LFBPRESC0_LEUART1_MASK
) >>

699 
_CMU_LFBPRESC0_LEUART1_SHIFT
));

700 
t
 = 
	`CMU_Log2ToDiv
(ret);

705 
	`EFM_ASSERT
(0);

706 
t
 = 
cmuClkDiv_1
;

712 
	`EFM_ASSERT
(0);

713 
t
 = 
cmuClkDiv_1
;

717 (
t
);

718 
	}
}

740 
	$CMU_ClockDivS
(
CMU_Clock_TyDef
 
ock
, 
CMU_ClkDiv_TyDef
 
div
)

742 
ut32_t
 
eq
;

743 
ut32_t
 
divReg
;

746 
divReg
 = (
ock
 >> 
CMU_DIV_REG_POS
& 
CMU_DIV_REG_MASK
;

748 
divReg
)

750 #i
	`defed
 (
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

751 
CMU_HFCLKDIV_REG
:

752 
	`EFM_ASSERT
((
div
>=
cmuClkDiv_1
&& (div<=
cmuClkDiv_8
));

755 
	`CMU_FshWaSMax
();

758 
CMU
->
CTRL
 = (CMU->CTRL & ~
_CMU_CTRL_HFCLKDIV_MASK
) |

759 ((
div
-1<< 
_CMU_CTRL_HFCLKDIV_SHIFT
);

763 
eq
 = 
	`SyemCeClockG
();

766 
	`CMU_FshWaSCڌ
(
eq
);

770 
CMU_HFPERCLKDIV_REG
:

771 
	`EFM_ASSERT
((
div
 >
cmuClkDiv_1
&& (div <
cmuClkDiv_512
));

773 
div
 = 
	`CMU_DivToLog2
(div);

774 
CMU
->
HFPERCLKDIV
 = (CMU->HFPERCLKDIV & ~
_CMU_HFPERCLKDIV_HFPERCLKDIV_MASK
) |

775 (
div
 << 
_CMU_HFPERCLKDIV_HFPERCLKDIV_SHIFT
);

778 
CMU_HFCORECLKDIV_REG
:

779 
	`EFM_ASSERT
(
div
 <
cmuClkDiv_512
);

782 
	`CMU_FshWaSMax
();

784 #i
	`defed
 (
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

787 i(
cmuSe_HFXO
 !
	`CMU_ClockSeG
(
cmuClock_HF
)) ||

788 ((
	`SyemHFXOClockG
()/
div
<
CMU_MAX_FREQ_HFLE
) )

791 
	`BITBAND_Ph
(&(
CMU
->
CTRL
), 
_CMU_CTRL_HFLE_SHIFT
, 0);

794 
	`BITBAND_Ph
(&(
CMU
->
HFCORECLKDIV
),

795 
_CMU_HFCORECLKDIV_HFCORECLKLEDIV_SHIFT
, 0);

800 
	`BITBAND_Ph
(&(
CMU
->
CTRL
), 
_CMU_CTRL_HFLE_SHIFT
, 1);

803 
	`BITBAND_Ph
(&(
CMU
->
HFCORECLKDIV
),

804 
_CMU_HFCORECLKDIV_HFCORECLKLEDIV_SHIFT
, 1);

809 
div
 = 
	`CMU_DivToLog2
(div);

811 
CMU
->
HFCORECLKDIV
 = (CMU->HFCORECLKDIV & ~
_CMU_HFCORECLKDIV_HFCORECLKDIV_MASK
) |

812 (
div
 << 
_CMU_HFCORECLKDIV_HFCORECLKDIV_SHIFT
);

816 
eq
 = 
	`SyemCeClockG
();

819 
	`CMU_FshWaSCڌ
(
eq
);

822 
CMU_LFAPRESC0_REG
:

823 
ock
)

825 
cmuClock_RTC
:

826 
	`EFM_ASSERT
(
div
 <
cmuClkDiv_32768
);

829 
	`CMU_Sync
(
CMU_SYNCBUSY_LFAPRESC0
);

832 
div
 = 
	`CMU_DivToLog2
(div);

834 
CMU
->
LFAPRESC0
 = (CMU->LFAPRESC0 & ~
_CMU_LFAPRESC0_RTC_MASK
) |

835 (
div
 << 
_CMU_LFAPRESC0_RTC_SHIFT
);

838 #i
	`defed
(
_CMU_LFAPRESC0_LETIMER0_MASK
)

839 
cmuClock_LETIMER0
:

840 
	`EFM_ASSERT
(
div
 <
cmuClkDiv_32768
);

843 
	`CMU_Sync
(
CMU_SYNCBUSY_LFAPRESC0
);

846 
div
 = 
	`CMU_DivToLog2
(div);

848 
CMU
->
LFAPRESC0
 = (CMU->LFAPRESC0 & ~
_CMU_LFAPRESC0_LETIMER0_MASK
) |

849 (
div
 << 
_CMU_LFAPRESC0_LETIMER0_SHIFT
);

853 #i
	`defed
(
LCD_PRESENT
)

854 
cmuClock_LCDe
:

855 
	`EFM_ASSERT
((
div
 >
cmuClkDiv_16
&& (div <
cmuClkDiv_128
));

858 
	`CMU_Sync
(
CMU_SYNCBUSY_LFAPRESC0
);

861 
div
 = 
	`CMU_DivToLog2
(div);

863 
CMU
->
LFAPRESC0
 = (CMU->LFAPRESC0 & ~
_CMU_LFAPRESC0_LCD_MASK
) |

864 ((
div
 - 
	`CMU_DivToLog2
(
cmuClkDiv_16
)<< 
_CMU_LFAPRESC0_LCD_SHIFT
);

868 #i
	`defed
(
LESENSE_PRESENT
)

869 
cmuClock_LESENSE
:

870 
	`EFM_ASSERT
(
div
 <
cmuClkDiv_8
);

873 
	`CMU_Sync
(
CMU_SYNCBUSY_LFAPRESC0
);

876 
div
 = 
	`CMU_DivToLog2
(div);

878 
CMU
->
LFAPRESC0
 = (CMU->LFAPRESC0 & ~
_CMU_LFAPRESC0_LESENSE_MASK
) |

879 (
div
 << 
_CMU_LFAPRESC0_LESENSE_SHIFT
);

884 
	`EFM_ASSERT
(0);

889 
CMU_LFBPRESC0_REG
:

890 
ock
)

892 #i
	`defed
(
_CMU_LFBPRESC0_LEUART0_MASK
)

893 
cmuClock_LEUART0
:

894 
	`EFM_ASSERT
(
div
 <
cmuClkDiv_8
);

897 
	`CMU_Sync
(
CMU_SYNCBUSY_LFBPRESC0
);

900 
div
 = 
	`CMU_DivToLog2
(div);

902 
CMU
->
LFBPRESC0
 = (CMU->LFBPRESC0 & ~
_CMU_LFBPRESC0_LEUART0_MASK
) |

903 (((
ut32_t
)
div
<< 
_CMU_LFBPRESC0_LEUART0_SHIFT
);

907 #i
	`defed
(
_CMU_LFBPRESC0_LEUART1_MASK
)

908 
cmuClock_LEUART1
:

909 
	`EFM_ASSERT
(
div
 <
cmuClkDiv_8
);

912 
	`CMU_Sync
(
CMU_SYNCBUSY_LFBPRESC0
);

915 
div
 = 
	`CMU_DivToLog2
(div);

917 
CMU
->
LFBPRESC0
 = (CMU->LFBPRESC0 & ~
_CMU_LFBPRESC0_LEUART1_MASK
) |

918 (((
ut32_t
)
div
<< 
_CMU_LFBPRESC0_LEUART1_SHIFT
);

923 
	`EFM_ASSERT
(0);

929 
	`EFM_ASSERT
(0);

932 
	}
}

962 
	$CMU_ClockEb
(
CMU_Clock_TyDef
 
ock
, 
bo
 
ab
)

964 vީ
ut32_t
 *
g
;

965 
ut32_t
 
b
;

966 
ut32_t
 
sync
 = 0;

969 (
ock
 >> 
CMU_EN_REG_POS
& 
CMU_EN_REG_MASK
)

971 
CMU_HFPERCLKDIV_EN_REG
:

972 
g
 = &(
CMU
->
HFPERCLKDIV
);

975 
CMU_HFPERCLKEN0_EN_REG
:

976 
g
 = &(
CMU
->
HFPERCLKEN0
);

979 
CMU_HFCORECLKEN0_EN_REG
:

980 
g
 = &(
CMU
->
HFCORECLKEN0
);

982 #i
	`defed
 (
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

985 i(
cmuSe_HFXO
 =
	`CMU_ClockSeG
(
cmuClock_HF
)) &&

986 ((
	`SyemHFXOClockG
()/
	`CMU_ClockDivG
(
cmuClock_CORE
)) >

987 
CMU_MAX_FREQ_HFLE
) )

990 
	`BITBAND_Ph
(&(
CMU
->
CTRL
), 
_CMU_CTRL_HFLE_SHIFT
, 1);

993 
	`BITBAND_Ph
(&(
CMU
->
HFCORECLKDIV
),

994 
_CMU_HFCORECLKDIV_HFCORECLKLEDIV_SHIFT
, 1);

999 
CMU_LFACLKEN0_EN_REG
:

1000 
g
 = &(
CMU
->
LFACLKEN0
);

1001 
sync
 = 
CMU_SYNCBUSY_LFACLKEN0
;

1004 
CMU_LFBCLKEN0_EN_REG
:

1005 
g
 = &(
CMU
->
LFBCLKEN0
);

1006 
sync
 = 
CMU_SYNCBUSY_LFBCLKEN0
;

1009 
CMU_PCNT_EN_REG
:

1010 
g
 = &(
CMU
->
PCNTCTRL
);

1014 
	`EFM_ASSERT
(0);

1019 
b
 = (
ock
 >> 
CMU_EN_BIT_POS
& 
CMU_EN_BIT_MASK
;

1022 i(
sync
)

1024 
	`CMU_Sync
(
sync
);

1028 
	`BITBAND_Ph
(
g
, 
b
, ()
ab
);

1029 
	}
}

1042 
ut32_t
 
	$CMU_ClockFqG
(
CMU_Clock_TyDef
 
ock
)

1044 
ut32_t
 
t
;

1046 
ock
 & (
CMU_CLK_BRANCH_MASK
 << 
CMU_CLK_BRANCH_POS
))

1048 (
CMU_HF_CLK_BRANCH
 << 
CMU_CLK_BRANCH_POS
):

1050 
t
 = 
	`SyemHFClockG
();

1051 #i
	`defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

1053 
t
 = / (1 + ((
CMU
->
CTRL
 & 
_CMU_CTRL_HFCLKDIV_MASK
) >>

1054 
_CMU_CTRL_HFCLKDIV_SHIFT
));

1059 #i
	`defed
(
_CMU_HFPERCLKEN0_USART0_MASK
) || \

1060 
	`defed
(
_CMU_HFPERCLKEN0_USART1_MASK
) || \

1061 
	`defed
(
_CMU_HFPERCLKEN0_USART2_MASK
) || \

1062 
	`defed
(
_CMU_HFPERCLKEN0_UART0_MASK
) || \

1063 
	`defed
(
_CMU_HFPERCLKEN0_UART1_MASK
) || \

1064 
	`defed
(
_CMU_HFPERCLKEN0_TIMER0_MASK
) || \

1065 
	`defed
(
_CMU_HFPERCLKEN0_TIMER1_MASK
) || \

1066 
	`defed
(
_CMU_HFPERCLKEN0_TIMER2_MASK
) || \

1067 
	`defed
(
_CMU_HFPERCLKEN0_TIMER3_MASK
) || \

1068 
	`defed
(
_CMU_HFPERCLKEN0_ACMP0_MASK
) || \

1069 
	`defed
(
_CMU_HFPERCLKEN0_ACMP1_MASK
) || \

1070 
	`defed
(
_CMU_HFPERCLKEN0_DAC0_MASK
) || \

1071 
	`defed
(
_CMU_HFPERCLKEN0_ADC0_MASK
) || \

1072 
	`defed
(
_CMU_HFPERCLKEN0_I2C0_MASK
) || \

1073 
	`defed
(
_CMU_HFPERCLKEN0_I2C1_MASK
) || \

1074 
	`defed
(
PRS_PRESENT
) || \

1075 
	`defed
(
VCMP_PRESENT
)|| \

1076 
	`defed
(
GPIO_PRESENT
)

1077 (
CMU_HFPER_CLK_BRANCH
 << 
CMU_CLK_BRANCH_POS
):

1079 
t
 = 
	`SyemHFClockG
();

1080 #i
	`defed
 (
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

1082 
t
 = / (1 + ((
CMU
->
CTRL
 & 
_CMU_CTRL_HFCLKDIV_MASK
) >>

1083 
_CMU_CTRL_HFCLKDIV_SHIFT
));

1085 
t
 >>(
CMU
->
HFPERCLKDIV
 & 
_CMU_HFPERCLKDIV_HFPERCLKDIV_MASK
) >>

1086 
_CMU_HFPERCLKDIV_HFPERCLKDIV_SHIFT
;

1091 #i
	`defed
(
AES_PRESENT
) || \

1092 
	`defed
(
DMA_PRESENT
) || \

1093 
	`defed
(
EBI_PRESENT
) || \

1094 
	`defed
(
USB_PRESENT
)

1095 (
CMU_HFCORE_CLK_BRANCH
 << 
CMU_CLK_BRANCH_POS
):

1097 
t
 = 
	`SyemCeClockG
();

1102 (
CMU_LFA_CLK_BRANCH
 << 
CMU_CLK_BRANCH_POS
):

1104 
t
 = 
	`CMU_LFClkG
(
CMU_LFA
);

1107 #i
	`defed
(
_CMU_LFACLKEN0_RTC_MASK
)

1108 (
CMU_RTC_CLK_BRANCH
 << 
CMU_CLK_BRANCH_POS
):

1110 
t
 = 
	`CMU_LFClkG
(
CMU_LFA
);

1111 
t
 >>(
CMU
->
LFAPRESC0
 & 
_CMU_LFAPRESC0_RTC_MASK
) >>

1112 
_CMU_LFAPRESC0_RTC_SHIFT
;

1116 #i
	`defed
(
_CMU_LFACLKEN0_LETIMER0_MASK
)

1117 (
CMU_LETIMER_CLK_BRANCH
 << 
CMU_CLK_BRANCH_POS
):

1119 
t
 = 
	`CMU_LFClkG
(
CMU_LFA
);

1120 
t
 >>(
CMU
->
LFAPRESC0
 & 
_CMU_LFAPRESC0_LETIMER0_MASK
) >>

1121 
_CMU_LFAPRESC0_LETIMER0_SHIFT
;

1125 #i
	`defed
(
_CMU_LFACLKEN0_LCD_MASK
)

1126 (
CMU_LCDPRE_CLK_BRANCH
 << 
CMU_CLK_BRANCH_POS
):

1128 
t
 = 
	`CMU_LFClkG
(
CMU_LFA
);

1129 
t
 >>((
CMU
->
LFAPRESC0
 & 
_CMU_LFAPRESC0_LCD_MASK
) >>

1130 
_CMU_LFAPRESC0_LCD_SHIFT
+ 
	`CMU_DivToLog2
(
cmuClkDiv_16
);

1134 (
CMU_LCD_CLK_BRANCH
 << 
CMU_CLK_BRANCH_POS
):

1136 
t
 = 
	`CMU_LFClkG
(
CMU_LFA
);

1137 
t
 >>(
CMU
->
LFAPRESC0
 & 
_CMU_LFAPRESC0_LCD_MASK
) >>

1138 
_CMU_LFAPRESC0_LCD_SHIFT
;

1139 
t
 /(1 + ((
CMU
->
LCDCTRL
 & 
_CMU_LCDCTRL_FDIV_MASK
) >>

1140 
_CMU_LCDCTRL_FDIV_SHIFT
));

1144 #i
	`defed
(
_CMU_LFACLKEN0_LESENSE_MASK
)

1145 (
CMU_LESENSE_CLK_BRANCH
 << 
CMU_CLK_BRANCH_POS
):

1147 
t
 = 
	`CMU_LFClkG
(
CMU_LFA
);

1148 
t
 >>(
CMU
->
LFAPRESC0
 & 
_CMU_LFAPRESC0_LESENSE_MASK
) >>

1149 
_CMU_LFAPRESC0_LESENSE_SHIFT
;

1153 (
CMU_LFB_CLK_BRANCH
 << 
CMU_CLK_BRANCH_POS
):

1155 
t
 = 
	`CMU_LFClkG
(
CMU_LFB
);

1158 #i
	`defed
(
_CMU_LFBCLKEN0_LEUART0_MASK
)

1159 (
CMU_LEUART0_CLK_BRANCH
 << 
CMU_CLK_BRANCH_POS
):

1161 
t
 = 
	`CMU_LFClkG
(
CMU_LFB
);

1162 
t
 >>(
CMU
->
LFBPRESC0
 & 
_CMU_LFBPRESC0_LEUART0_MASK
) >>

1163 
_CMU_LFBPRESC0_LEUART0_SHIFT
;

1167 #i
	`defed
(
_CMU_LFBCLKEN0_LEUART1_MASK
)

1168 (
CMU_LEUART1_CLK_BRANCH
 << 
CMU_CLK_BRANCH_POS
):

1170 
t
 = 
	`CMU_LFClkG
(
CMU_LFB
);

1171 
t
 >>(
CMU
->
LFBPRESC0
 & 
_CMU_LFBPRESC0_LEUART1_MASK
) >>

1172 
_CMU_LFBPRESC0_LEUART1_SHIFT
;

1177 (
CMU_DBG_CLK_BRANCH
 << 
CMU_CLK_BRANCH_POS
):

1179 
t
 = 
	`CMU_DBGClkG
();

1183 (
CMU_AUX_CLK_BRANCH
 << 
CMU_CLK_BRANCH_POS
):

1185 
t
 = 
	`CMU_AUXClkG
();

1189 #i
	`defed
(
USB_PRESENT
)

1190 (
CMU_USBC_CLK_BRANCH
 << 
CMU_CLK_BRANCH_POS
):

1192 
t
 = 
	`CMU_USBCClkG
();

1198 
	`EFM_ASSERT
(0);

1199 
t
 = 0;

1203  
t
;

1204 
	}
}

1223 
CMU_Se_TyDef
 
	$CMU_ClockSeG
(
CMU_Clock_TyDef
 
ock
)

1225 
CMU_Se_TyDef
 
t
 = 
cmuSe_Dibd
;

1226 
ut32_t
 
lReg
;

1228 
lReg
 = (
ock
 >> 
CMU_SEL_REG_POS
& 
CMU_SEL_REG_MASK
;

1230 
lReg
)

1232 
CMU_HFCLKSEL_REG
:

1233 
CMU
->
STATUS
 & (
CMU_STATUS_HFRCOSEL
 | 
CMU_STATUS_HFXOSEL
 |

1234 
CMU_STATUS_LFRCOSEL
 | 
CMU_STATUS_LFXOSEL
))

1236 
CMU_STATUS_LFXOSEL
:

1237 
t
 = 
cmuSe_LFXO
;

1240 
CMU_STATUS_LFRCOSEL
:

1241 
t
 = 
cmuSe_LFRCO
;

1244 
CMU_STATUS_HFXOSEL
:

1245 
t
 = 
cmuSe_HFXO
;

1249 
t
 = 
cmuSe_HFRCO
;

1254 
CMU_LFACLKSEL_REG
:

1255 
CMU
->
LFCLKSEL
 & 
_CMU_LFCLKSEL_LFA_MASK
)

1257 
CMU_LFCLKSEL_LFA_LFRCO
:

1258 
t
 = 
cmuSe_LFRCO
;

1261 
CMU_LFCLKSEL_LFA_LFXO
:

1262 
t
 = 
cmuSe_LFXO
;

1265 
CMU_LFCLKSEL_LFA_HFCORECLKLEDIV2
:

1266 
t
 = 
cmuSe_CORELEDIV2
;

1270 #i
	`defed
(
_EFM32_TINY_FAMILY
|| defed(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

1271 i(
CMU
->
LFCLKSEL
 & 
_CMU_LFCLKSEL_LFAE_MASK
)

1273 
t
 = 
cmuSe_ULFRCO
;

1277 
t
 = 
cmuSe_Dibd
;

1283 
CMU_LFBCLKSEL_REG
:

1284 
CMU
->
LFCLKSEL
 & 
_CMU_LFCLKSEL_LFB_MASK
)

1286 
CMU_LFCLKSEL_LFB_LFRCO
:

1287 
t
 = 
cmuSe_LFRCO
;

1290 
CMU_LFCLKSEL_LFB_LFXO
:

1291 
t
 = 
cmuSe_LFXO
;

1294 
CMU_LFCLKSEL_LFB_HFCORECLKLEDIV2
:

1295 
t
 = 
cmuSe_CORELEDIV2
;

1299 #i
	`defed
(
_EFM32_TINY_FAMILY
|| defed(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

1300 i(
CMU
->
LFCLKSEL
 & 
_CMU_LFCLKSEL_LFBE_MASK
)

1302 
t
 = 
cmuSe_ULFRCO
;

1306 
t
 = 
cmuSe_Dibd
;

1312 
CMU_DBGCLKSEL_REG
:

1313 #i
	`defed
(
_EFM32_TINY_FAMILY
|| defed(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

1314 
CMU
->
CTRL
 & 
_CMU_CTRL_DBGCLK_MASK
)

1316 
CMU_CTRL_DBGCLK_AUXHFRCO
:

1317 
t
 = 
cmuSe_AUXHFRCO
;

1320 
CMU_CTRL_DBGCLK_HFCLK
:

1321 
t
 = 
cmuSe_HFCLK
;

1325 #i
	`defed
(
_EFM32_GECKO_FAMILY
)

1326 
t
 = 
cmuSe_AUXHFRCO
;

1331 #i
	`defed
(
USB_PRESENT
)

1332 
CMU_USBCCLKSEL_REG
:

1333 
CMU
->
STATUS
 & (
CMU_STATUS_USBCHFCLKSEL
 |

1334 
CMU_STATUS_USBCLFXOSEL
 |

1335 
CMU_STATUS_USBCLFRCOSEL
))

1337 
CMU_STATUS_USBCHFCLKSEL
:

1338 
t
 = 
cmuSe_HFCLK
;

1341 
CMU_STATUS_USBCLFXOSEL
:

1342 
t
 = 
cmuSe_LFXO
;

1345 
CMU_STATUS_USBCLFRCOSEL
:

1346 
t
 = 
cmuSe_LFRCO
;

1350 
t
 = 
cmuSe_Dibd
;

1357 
	`EFM_ASSERT
(0);

1358 
t
 = 
cmuSe_E
;

1362  
t
;

1363 
	}
}

1400 
	$CMU_ClockSeS
(
CMU_Clock_TyDef
 
ock
, 
CMU_Se_TyDef
 
f
)

1402 
ut32_t
 

 = 
cmuOsc_HFRCO
;

1403 
CMU_Osc_TyDef
 
osc
 = 
cmuOsc_HFRCO
;

1404 
ut32_t
 
eq
;

1405 
ut32_t
 
lReg
;

1406 #i
	`defed
(
_EFM32_TINY_FAMILY
|| defed(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

1407 
ut32_t
 
lfExnded
 = 0;

1409 
ut32_t
 
tmp
;

1411 
lReg
 = (
ock
 >> 
CMU_SEL_REG_POS
& 
CMU_SEL_REG_MASK
;

1413 
lReg
)

1415 
CMU_HFCLKSEL_REG
:

1416 
f
)

1418 
cmuSe_LFXO
:

1419 

 = 
CMU_CMD_HFCLKSEL_LFXO
;

1420 
osc
 = 
cmuOsc_LFXO
;

1423 
cmuSe_LFRCO
:

1424 

 = 
CMU_CMD_HFCLKSEL_LFRCO
;

1425 
osc
 = 
cmuOsc_LFRCO
;

1428 
cmuSe_HFXO
:

1429 

 = 
CMU_CMD_HFCLKSEL_HFXO
;

1430 
osc
 = 
cmuOsc_HFXO
;

1431 #i
	`defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

1434 if(
	`SyemHFXOClockG
(> 
CMU_MAX_FREQ_HFLE
)

1436 
CMU
->
CTRL
 = (CMU->CTRL & ~
_CMU_CTRL_HFXOBUFCUR_MASK
) |

1437 
CMU_CTRL_HFXOBUFCUR_BOOSTABOVE32MHZ
 |

1439 
CMU_CTRL_HFLE
;

1443 i(
CMU
->
HFCORECLKEN0
 & 
CMU_HFCORECLKEN0_LE
)

1445 
	`BITBAND_Ph
(&(
CMU
->
HFCORECLKDIV
),

1446 
_CMU_HFCORECLKDIV_HFCORECLKLEDIV_SHIFT
, 1);

1453 
CMU
->
CTRL
 = (CMU->CTRL & ~
_CMU_CTRL_HFXOBUFCUR_MASK
) |

1454 
CMU_CTRL_HFXOBUFCUR_BOOSTUPTO32MHZ
;

1459 
cmuSe_HFRCO
:

1460 

 = 
CMU_CMD_HFCLKSEL_HFRCO
;

1461 
osc
 = 
cmuOsc_HFRCO
;

1464 #i
	`defed
(
_EFM32_TINY_FAMILY
|| defed(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

1465 
cmuSe_ULFRCO
:

1467 
	`EFM_ASSERT
(0);

1472 
	`EFM_ASSERT
(0);

1477 
	`CMU_OsctEb
(
osc
, 
ue
,rue);

1480 
	`CMU_FshWaSMax
();

1483 
CMU
->
CMD
 = 

;

1486 
	`EMU_UpdeOscCfig
();

1490 
eq
 = 
	`SyemCeClockG
();

1493 
	`CMU_FshWaSCڌ
(
eq
);

1496 
CMU_LFACLKSEL_REG
:

1497 
CMU_LFBCLKSEL_REG
:

1499 
f
)

1501 
cmuSe_Dibd
:

1502 
tmp
 = 
_CMU_LFCLKSEL_LFA_DISABLED
;

1505 
cmuSe_LFXO
:

1507 
	`CMU_OsctEb
(
cmuOsc_LFXO
, 
ue
,rue);

1508 
tmp
 = 
_CMU_LFCLKSEL_LFA_LFXO
;

1511 
cmuSe_LFRCO
:

1513 
	`CMU_OsctEb
(
cmuOsc_LFRCO
, 
ue
,rue);

1514 
tmp
 = 
_CMU_LFCLKSEL_LFA_LFRCO
;

1517 
cmuSe_CORELEDIV2
:

1519 
	`BITBAND_Ph
(&(
CMU
->
HFCORECLKEN0
), 
_CMU_HFCORECLKEN0_LE_SHIFT
, 1);

1520 
tmp
 = 
_CMU_LFCLKSEL_LFA_HFCORECLKLEDIV2
;

1521 #i
	`defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

1523 
eq
 = 
	`SyemCeClockG
();

1524 if(
eq
 > 
CMU_MAX_FREQ_HFLE
)

1527 
	`BITBAND_Ph
(&(
CMU
->
CTRL
), 
_CMU_CTRL_HFLE_SHIFT
, 1);

1530 
	`BITBAND_Ph
(&(
CMU
->
HFCORECLKDIV
),

1531 
_CMU_HFCORECLKDIV_HFCORECLKLEDIV_SHIFT
, 1);

1536 #i
	`defed
(
_EFM32_TINY_FAMILY
|| defed(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

1537 
cmuSe_ULFRCO
:

1539 
tmp
 = 
_CMU_LFCLKSEL_LFA_DISABLED
;

1540 
lfExnded
 = 1;

1546 
	`EFM_ASSERT
(0);

1551 i(
lReg
 =
CMU_LFACLKSEL_REG
)

1553 #i
	`defed
(
_EFM32_TINY_FAMILY
|| defed(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

1554 
CMU
->
LFCLKSEL
 = (CMU->LFCLKSEL & ~(
_CMU_LFCLKSEL_LFA_MASK
 | 
_CMU_LFCLKSEL_LFAE_MASK
) ) |

1555 (
tmp
 << 
_CMU_LFCLKSEL_LFA_SHIFT
| (
lfExnded
 << 
_CMU_LFCLKSEL_LFAE_SHIFT
);

1557 
CMU
->
LFCLKSEL
 = (CMU->LFCLKSEL & ~
_CMU_LFCLKSEL_LFA_MASK
) |

1558 (
tmp
 << 
_CMU_LFCLKSEL_LFA_SHIFT
);

1563 #i
	`defed
(
_EFM32_TINY_FAMILY
|| defed(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

1564 
CMU
->
LFCLKSEL
 = (CMU->LFCLKSEL & ~(
_CMU_LFCLKSEL_LFB_MASK
 | 
_CMU_LFCLKSEL_LFBE_MASK
) ) |

1565 (
tmp
 << 
_CMU_LFCLKSEL_LFB_SHIFT
| (
lfExnded
 << 
_CMU_LFCLKSEL_LFBE_SHIFT
);

1567 
CMU
->
LFCLKSEL
 = (CMU->LFCLKSEL & ~
_CMU_LFCLKSEL_LFB_MASK
) |

1568 (
tmp
 << 
_CMU_LFCLKSEL_LFB_SHIFT
);

1573 #i
	`defed
(
_EFM32_TINY_FAMILY
|| defed(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

1574 
CMU_DBGCLKSEL_REG
:

1575 
f
)

1577 
cmuSe_AUXHFRCO
:

1579 
CMU
->
CTRL
 = (CMU->CTRL & ~(
_CMU_CTRL_DBGCLK_MASK
))| 
CMU_CTRL_DBGCLK_AUXHFRCO
;

1582 
cmuSe_HFCLK
:

1584 
CMU
->
CTRL
 = (CMU->CTRL & ~(
_CMU_CTRL_DBGCLK_MASK
))| 
CMU_CTRL_DBGCLK_HFCLK
;

1589 
	`EFM_ASSERT
(0);

1595 #i
	`defed
(
USB_PRESENT
)

1596 
CMU_USBCCLKSEL_REG
:

1597 
f
)

1600 
cmuSe_HFCLK
:

1603 
CMU
->
CMD
 = 
CMU_CMD_USBCCLKSEL_HFCLKNODIV
;

1605 (
CMU
->
STATUS
 & 
CMU_STATUS_USBCHFCLKSEL
)==0);

1608 
cmuSe_LFXO
:

1612 
	`CMU_OsctEb
(
cmuOsc_LFXO
, 
ue
,rue);

1615 
CMU
->
CMD
 = 
CMU_CMD_USBCCLKSEL_LFXO
;

1618 (
CMU
->
STATUS
 & 
CMU_STATUS_USBCLFXOSEL
)==0);

1621 
cmuSe_LFRCO
:

1625 
	`CMU_OsctEb
(
cmuOsc_LFRCO
, 
ue
,rue);

1628 
CMU
->
CMD
 = 
CMU_CMD_USBCCLKSEL_LFRCO
;

1631 (
CMU
->
STATUS
 & 
CMU_STATUS_USBCLFRCOSEL
)==0);

1636 
	`EFM_ASSERT
(0);

1644 
	`EFM_ASSERT
(0);

1647 
	}
}

1679 
	$CMU_FezeEb
(
bo
 
ab
)

1681 i(
ab
)

1690 
CMU
->
SYNCBUSY
)

1693 
CMU
->
FREEZE
 = 
CMU_FREEZE_REGFREEZE
;

1697 
CMU
->
FREEZE
 = 0;

1699 
	}
}

1702 #i
defed
(
_EFM32_TINY_FAMILY
|| defed(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

1710 
CMU_AUXHFRCOBd_TyDef
 
	$CMU_AUXHFRCOBdG
()

1712  (
CMU_AUXHFRCOBd_TyDef
)((
CMU
->
AUXHFRCOCTRL
 & 
_CMU_AUXHFRCOCTRL_BAND_MASK
) >>

1713 
_CMU_AUXHFRCOCTRL_BAND_SHIFT
);

1714 
	}
}

1724 
	$CMU_AUXHFRCOBdS
(
CMU_AUXHFRCOBd_TyDef
 
bd
)

1726 
ut32_t
 
tung
;

1729 
bd
)

1731 
cmuAUXHFRCOBd_1MHz
:

1732 
tung
 = (
DEVINFO
->
AUXHFRCOCAL0
 & 
_DEVINFO_AUXHFRCOCAL0_BAND1_MASK
) >>

1733 
_DEVINFO_AUXHFRCOCAL0_BAND1_SHIFT
;

1736 
cmuAUXHFRCOBd_7MHz
:

1737 
tung
 = (
DEVINFO
->
AUXHFRCOCAL0
 & 
_DEVINFO_AUXHFRCOCAL0_BAND7_MASK
) >>

1738 
_DEVINFO_AUXHFRCOCAL0_BAND7_SHIFT
;

1741 
cmuAUXHFRCOBd_11MHz
:

1742 
tung
 = (
DEVINFO
->
AUXHFRCOCAL0
 & 
_DEVINFO_AUXHFRCOCAL0_BAND11_MASK
) >>

1743 
_DEVINFO_AUXHFRCOCAL0_BAND11_SHIFT
;

1746 
cmuAUXHFRCOBd_14MHz
:

1747 
tung
 = (
DEVINFO
->
AUXHFRCOCAL0
 & 
_DEVINFO_AUXHFRCOCAL0_BAND14_MASK
) >>

1748 
_DEVINFO_AUXHFRCOCAL0_BAND14_SHIFT
;

1751 
cmuAUXHFRCOBd_21MHz
:

1752 
tung
 = (
DEVINFO
->
AUXHFRCOCAL1
 & 
_DEVINFO_AUXHFRCOCAL1_BAND21_MASK
) >>

1753 
_DEVINFO_AUXHFRCOCAL1_BAND21_SHIFT
;

1756 
cmuAUXHFRCOBd_28MHz
:

1757 
tung
 = (
DEVINFO
->
AUXHFRCOCAL1
 & 
_DEVINFO_AUXHFRCOCAL1_BAND28_MASK
) >>

1758 
_DEVINFO_AUXHFRCOCAL1_BAND28_SHIFT
;

1762 
	`EFM_ASSERT
(0);

1767 
CMU
->
AUXHFRCOCTRL
 = (CMU->AUXHFRCOCTRL &

1768 ~(
_CMU_AUXHFRCOCTRL_BAND_MASK
 | 
_CMU_AUXHFRCOCTRL_TUNING_MASK
)) |

1769 (
bd
 << 
_CMU_AUXHFRCOCTRL_BAND_SHIFT
) |

1770 (
tung
 << 
_CMU_AUXHFRCOCTRL_TUNING_SHIFT
);

1772 
	}
}

1783 
CMU_HFRCOBd_TyDef
 
	$CMU_HFRCOBdG
()

1785  (
CMU_HFRCOBd_TyDef
)((
CMU
->
HFRCOCTRL
 & 
_CMU_HFRCOCTRL_BAND_MASK
) >>

1786 
_CMU_HFRCOCTRL_BAND_SHIFT
);

1787 
	}
}

1798 
	$CMU_HFRCOBdS
(
CMU_HFRCOBd_TyDef
 
bd
)

1800 
ut32_t
 
tung
;

1801 
ut32_t
 
eq
;

1802 
CMU_Se_TyDef
 
osc
;

1805 
bd
)

1807 
cmuHFRCOBd_1MHz
:

1808 
tung
 = (
DEVINFO
->
HFRCOCAL0
 & 
_DEVINFO_HFRCOCAL0_BAND1_MASK
) >>

1809 
_DEVINFO_HFRCOCAL0_BAND1_SHIFT
;

1812 
cmuHFRCOBd_7MHz
:

1813 
tung
 = (
DEVINFO
->
HFRCOCAL0
 & 
_DEVINFO_HFRCOCAL0_BAND7_MASK
) >>

1814 
_DEVINFO_HFRCOCAL0_BAND7_SHIFT
;

1817 
cmuHFRCOBd_11MHz
:

1818 
tung
 = (
DEVINFO
->
HFRCOCAL0
 & 
_DEVINFO_HFRCOCAL0_BAND11_MASK
) >>

1819 
_DEVINFO_HFRCOCAL0_BAND11_SHIFT
;

1822 
cmuHFRCOBd_14MHz
:

1823 
tung
 = (
DEVINFO
->
HFRCOCAL0
 & 
_DEVINFO_HFRCOCAL0_BAND14_MASK
) >>

1824 
_DEVINFO_HFRCOCAL0_BAND14_SHIFT
;

1827 
cmuHFRCOBd_21MHz
:

1828 
tung
 = (
DEVINFO
->
HFRCOCAL1
 & 
_DEVINFO_HFRCOCAL1_BAND21_MASK
) >>

1829 
_DEVINFO_HFRCOCAL1_BAND21_SHIFT
;

1832 
cmuHFRCOBd_28MHz
:

1833 
tung
 = (
DEVINFO
->
HFRCOCAL1
 & 
_DEVINFO_HFRCOCAL1_BAND28_MASK
) >>

1834 
_DEVINFO_HFRCOCAL1_BAND28_SHIFT
;

1838 
	`EFM_ASSERT
(0);

1843 
osc
 = 
	`CMU_ClockSeG
(
cmuClock_HF
);

1844 i(
osc
 =
cmuSe_HFRCO
)

1847 
	`CMU_FshWaSMax
();

1851 
CMU
->
HFRCOCTRL
 = (CMU->HFRCOCTRL &

1852 ~(
_CMU_HFRCOCTRL_BAND_MASK
 | 
_CMU_HFRCOCTRL_TUNING_MASK
)) |

1853 (
bd
 << 
_CMU_HFRCOCTRL_BAND_SHIFT
) |

1854 (
tung
 << 
_CMU_HFRCOCTRL_TUNING_SHIFT
);

1857 i(
osc
 =
cmuSe_HFRCO
)

1863 
eq
 = 
	`SyemCeClockG
();

1866 
	`CMU_FshWaSCڌ
(
eq
);

1868 
	}
}

1881 
ut32_t
 
	$CMU_HFRCOSupDayG
()

1883 ((
CMU
->
HFRCOCTRL
 & 
_CMU_HFRCOCTRL_SUDELAY_MASK
) >>

1884 
_CMU_HFRCOCTRL_SUDELAY_SHIFT
);

1885 
	}
}

1898 
	$CMU_HFRCOSupDayS
(
ut32_t
 
day
)

1900 
	`EFM_ASSERT
(
day
 <= 31);

1902 
day
 &(
_CMU_HFRCOCTRL_SUDELAY_MASK
 >> 
_CMU_HFRCOCTRL_SUDELAY_SHIFT
);

1903 
CMU
->
HFRCOCTRL
 = (CMU->HFRCOCTRL & ~(
_CMU_HFRCOCTRL_SUDELAY_MASK
)) |

1904 (
day
 << 
_CMU_HFRCOCTRL_SUDELAY_SHIFT
);

1905 
	}
}

1915 
ut32_t
 
	$CMU_LCDClkFDIVG
()

1917 #i
	`defed
(
LCD_PRESENT
)

1918 ((
CMU
->
LCDCTRL
 & 
_CMU_LCDCTRL_FDIV_MASK
>> 
_CMU_LCDCTRL_FDIV_SHIFT
);

1922 
	}
}

1938 
	$CMU_LCDClkFDIVS
(
ut32_t
 
div
)

1940 #i
	`defed
(
LCD_PRESENT
)

1941 
	`EFM_ASSERT
(
div
 <
cmuClkDiv_128
);

1944 i(
CMU
->
LFACLKEN0
 & 
CMU_LFACLKEN0_LCD
)

1949 
div
 <<
_CMU_LCDCTRL_FDIV_SHIFT
;

1950 
div
 &
_CMU_LCDCTRL_FDIV_MASK
;

1951 
CMU
->
LCDCTRL
 = (CMU->LCDCTRL & ~
_CMU_LCDCTRL_FDIV_MASK
| 
div
;

1953 ()
div
;

1955 
	}
}

1982 
	$CMU_OsctEb
(
CMU_Osc_TyDef
 
osc
, 
bo
 
ab
, bo 
wa
)

1984 
ut32_t
 
us
;

1985 
ut32_t
 
B
;

1986 
ut32_t
 
disB
;

1988 
osc
)

1990 
cmuOsc_HFRCO
:

1991 
B
 = 
CMU_OSCENCMD_HFRCOEN
;

1992 
disB
 = 
CMU_OSCENCMD_HFRCODIS
;

1993 
us
 = 
CMU_STATUS_HFRCORDY
;

1996 
cmuOsc_HFXO
:

1997 
B
 = 
CMU_OSCENCMD_HFXOEN
;

1998 
disB
 = 
CMU_OSCENCMD_HFXODIS
;

1999 
us
 = 
CMU_STATUS_HFXORDY
;

2002 
cmuOsc_AUXHFRCO
:

2003 
B
 = 
CMU_OSCENCMD_AUXHFRCOEN
;

2004 
disB
 = 
CMU_OSCENCMD_AUXHFRCODIS
;

2005 
us
 = 
CMU_STATUS_AUXHFRCORDY
;

2008 
cmuOsc_LFRCO
:

2009 
B
 = 
CMU_OSCENCMD_LFRCOEN
;

2010 
disB
 = 
CMU_OSCENCMD_LFRCODIS
;

2011 
us
 = 
CMU_STATUS_LFRCORDY
;

2014 
cmuOsc_LFXO
:

2015 
B
 = 
CMU_OSCENCMD_LFXOEN
;

2016 
disB
 = 
CMU_OSCENCMD_LFXODIS
;

2017 
us
 = 
CMU_STATUS_LFXORDY
;

2020 #i
defed
 
_CMU_LFCLKSEL_LFAE_ULFRCO


2021 
cmuOsc_ULFRCO
:

2028 
	`EFM_ASSERT
(0);

2032 i(
ab
)

2034 
CMU
->
OSCENCMD
 = 
B
;

2037 i(
wa
)

2039 !(
CMU
->
STATUS
 & 
us
))

2045 
CMU
->
OSCENCMD
 = 
disB
;

2049 
	`EMU_UpdeOscCfig
();

2050 
	}
}

2066 
ut32_t
 
	$CMU_OsctTungG
(
CMU_Osc_TyDef
 
osc
)

2068 
ut32_t
 
t
;

2070 
osc
)

2072 
cmuOsc_LFRCO
:

2073 
t
 = (
CMU
->
LFRCOCTRL
 & 
_CMU_LFRCOCTRL_TUNING_MASK
) >>

2074 
_CMU_LFRCOCTRL_TUNING_SHIFT
;

2077 
cmuOsc_HFRCO
:

2078 
t
 = (
CMU
->
HFRCOCTRL
 & 
_CMU_HFRCOCTRL_TUNING_MASK
) >>

2079 
_CMU_HFRCOCTRL_TUNING_SHIFT
;

2082 
cmuOsc_AUXHFRCO
:

2083 
t
 = (
CMU
->
AUXHFRCOCTRL
 & 
_CMU_AUXHFRCOCTRL_TUNING_MASK
) >>

2084 
_CMU_AUXHFRCOCTRL_TUNING_SHIFT
;

2088 
	`EFM_ASSERT
(0);

2089 
t
 = 0;

2093 (
t
);

2094 
	}
}

2115 
	$CMU_OsctTungS
(
CMU_Osc_TyDef
 
osc
, 
ut32_t
 
v
)

2117 
osc
)

2119 
cmuOsc_LFRCO
:

2120 
	`EFM_ASSERT
(
v
 <(
_CMU_LFRCOCTRL_TUNING_MASK
 >> 
_CMU_LFRCOCTRL_TUNING_SHIFT
));

2122 
v
 &(
_CMU_LFRCOCTRL_TUNING_MASK
 >> 
_CMU_LFRCOCTRL_TUNING_SHIFT
);

2123 
CMU
->
LFRCOCTRL
 = (CMU->LFRCOCTRL & ~(
_CMU_LFRCOCTRL_TUNING_MASK
)) |

2124 (
v
 << 
_CMU_LFRCOCTRL_TUNING_SHIFT
);

2127 
cmuOsc_HFRCO
:

2128 
	`EFM_ASSERT
(
v
 <(
_CMU_HFRCOCTRL_TUNING_MASK
 >> 
_CMU_HFRCOCTRL_TUNING_SHIFT
));

2130 
v
 &(
_CMU_HFRCOCTRL_TUNING_MASK
 >> 
_CMU_HFRCOCTRL_TUNING_SHIFT
);

2131 
CMU
->
HFRCOCTRL
 = (CMU->HFRCOCTRL & ~(
_CMU_HFRCOCTRL_TUNING_MASK
)) |

2132 (
v
 << 
_CMU_HFRCOCTRL_TUNING_SHIFT
);

2135 
cmuOsc_AUXHFRCO
:

2136 
	`EFM_ASSERT
(
v
 <(
_CMU_AUXHFRCOCTRL_TUNING_MASK
 >> 
_CMU_AUXHFRCOCTRL_TUNING_SHIFT
));

2138 
v
 <<
_CMU_AUXHFRCOCTRL_TUNING_SHIFT
;

2139 
v
 &
_CMU_AUXHFRCOCTRL_TUNING_MASK
;

2140 
CMU
->
AUXHFRCOCTRL
 = (CMU->AUXHFRCOCTRL & ~(
_CMU_AUXHFRCOCTRL_TUNING_MASK
)| 
v
;

2144 
	`EFM_ASSERT
(0);

2147 
	}
}

2161 
bo
 
	$CMU_PCNTClockExG
(

)

2163 
bo
 
t
;

2164 
ut32_t
 
g
;

2166 

)

2168 #i
	`defed
(
_CMU_PCNTCTRL_PCNT0CLKEN_MASK
)

2170 
g
 = 
CMU
->
PCNTCTRL
 & 
CMU_PCNTCTRL_PCNT0CLKSEL_PCNT0S0
;

2173 #i
	`defed
(
_CMU_PCNTCTRL_PCNT1CLKEN_MASK
)

2175 
g
 = 
CMU
->
PCNTCTRL
 & 
CMU_PCNTCTRL_PCNT1CLKSEL_PCNT1S0
;

2178 #i
	`defed
(
_CMU_PCNTCTRL_PCNT2CLKEN_MASK
)

2180 
g
 = 
CMU
->
PCNTCTRL
 & 
CMU_PCNTCTRL_PCNT2CLKSEL_PCNT2S0
;

2187 
g
 = 0;

2191 i(
g
)

2193 
t
 = 
ue
;

2197 
t
 = 
l
;

2199  
t
;

2200 
	}
}

2213 
	$CMU_PCNTClockExS
(

, 
bo
 
ex
)

2215 #i
	`defed
(
PCNT_PRESENT
)

2216 
ut32_t
 
g
 = 0;

2218 
	`EFM_ASSERT
(

 < 
PCNT_COUNT
);

2220 i(
ex
)

2222 
g
 = 1;

2225 
	`BITBAND_Ph
(&(
CMU
->
PCNTCTRL
), (

 * 2+ 1, 
g
);

2228 ()

;

2229 ()
ex
;

2231 
	}
}

	@C:\Users\Alexander\AppData\Roaming\energymicro\emlib\src\em_ebi.c

33 
	~"em_ebi.h
"

34 #i
defed
(
EBI_COUNT
) && (EBI_COUNT > 0)

35 
	~"em_as.h
"

36 
	~"em_bbd.h
"

60 
	$EBI_In
(cڡ 
EBI_In_TyDef
 *
ebiIn
)

62 
ut32_t
 

 = 
EBI
->
CTRL
;

64 #i
	`defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

66 

 |
EBI_CTRL_ITS
;

69 
	`EBI_BkPެyS
(
ebiIn
->
bks
, 
ebiLeARDY
,biIn->
dyPެy
);

71 
	`EBI_BkPެyS
(
ebiIn
->
bks
, 
ebiLeALE
,biIn->
ePެy
);

73 
	`EBI_BkPެyS
(
ebiIn
->
bks
, 
ebiLeWE
,biIn->
wePެy
);

75 
	`EBI_BkPެyS
(
ebiIn
->
bks
, 
ebiLeRE
,biIn->
Pެy
);

77 
	`EBI_BkPެyS
(
ebiIn
->
bks
, 
ebiLeCS
,biIn->
csPެy
);

79 
	`EBI_BkPެyS
(
ebiIn
->
bks
, 
ebiLeBL
,biIn->
blPެy
);

82 
	`EBI_PެyS
(
ebiLeARDY
, 
ebiIn
->
dyPެy
);

84 
	`EBI_PެyS
(
ebiLeALE
, 
ebiIn
->
ePެy
);

86 
	`EBI_PެyS
(
ebiLeWE
, 
ebiIn
->
wePެy
);

88 
	`EBI_PެyS
(
ebiLeRE
, 
ebiIn
->
Pެy
);

90 
	`EBI_PެyS
(
ebiLeCS
, 
ebiIn
->
csPެy
);

94 #i
	`defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

95 i(
ebiIn
->
bks
 & 
EBI_BANK0
)

97 

 &~(
_EBI_CTRL_MODE_MASK
|

98 
_EBI_CTRL_ARDYEN_MASK
|

99 
_EBI_CTRL_ARDYTODIS_MASK
|

100 
_EBI_CTRL_BL_MASK
|

101 
_EBI_CTRL_NOIDLE_MASK
|

102 
_EBI_CTRL_BANK0EN_MASK
);

103 

 |(
ebiIn
->
mode
 << 
_EBI_CTRL_MODE_SHIFT
);

104 

 |(
ebiIn
->
dyEb
 << 
_EBI_CTRL_ARDYEN_SHIFT
);

105 

 |(
ebiIn
->
dyDibTimeout
 << 
_EBI_CTRL_ARDYTODIS_SHIFT
);

106 

 |(
ebiIn
->
blEb
 << 
_EBI_CTRL_BL_SHIFT
);

107 

 |(
ebiIn
->
noId
 << 
_EBI_CTRL_NOIDLE_SHIFT
);

108 i
ebiIn
->
ab
)

110 

 |
EBI_CTRL_BANK0EN
;

113 i(
ebiIn
->
bks
 & 
EBI_BANK1
)

115 

 &~(
_EBI_CTRL_BL1_MASK
|

116 
_EBI_CTRL_MODE1_MASK
|

117 
_EBI_CTRL_ARDY1EN_MASK
|

118 
_EBI_CTRL_ARDYTO1DIS_MASK
|

119 
_EBI_CTRL_NOIDLE1_MASK
|

120 
_EBI_CTRL_BANK1EN_MASK
);

121 

 |(
ebiIn
->
mode
 << 
_EBI_CTRL_MODE1_SHIFT
);

122 

 |(
ebiIn
->
dyEb
 << 
_EBI_CTRL_ARDY1EN_SHIFT
);

123 

 |(
ebiIn
->
dyDibTimeout
 << 
_EBI_CTRL_ARDYTO1DIS_SHIFT
);

124 

 |(
ebiIn
->
blEb
 << 
_EBI_CTRL_BL1_SHIFT
);

125 

 |(
ebiIn
->
noId
 << 
_EBI_CTRL_NOIDLE1_SHIFT
);

126 i
ebiIn
->
ab
)

128 

 |
EBI_CTRL_BANK1EN
;

131 i(
ebiIn
->
bks
 & 
EBI_BANK2
)

133 

 &~(
_EBI_CTRL_BL2_MASK
|

134 
_EBI_CTRL_MODE2_MASK
|

135 
_EBI_CTRL_ARDY2EN_MASK
|

136 
_EBI_CTRL_ARDYTO2DIS_MASK
|

137 
_EBI_CTRL_NOIDLE2_MASK
|

138 
_EBI_CTRL_BANK2EN_MASK
);

139 

 |(
ebiIn
->
mode
 << 
_EBI_CTRL_MODE2_SHIFT
);

140 

 |(
ebiIn
->
dyEb
 << 
_EBI_CTRL_ARDY2EN_SHIFT
);

141 

 |(
ebiIn
->
dyDibTimeout
 << 
_EBI_CTRL_ARDYTO2DIS_SHIFT
);

142 

 |(
ebiIn
->
blEb
 << 
_EBI_CTRL_BL2_SHIFT
);

143 

 |(
ebiIn
->
noId
 << 
_EBI_CTRL_NOIDLE2_SHIFT
);

144 i
ebiIn
->
ab
)

146 

 |
EBI_CTRL_BANK2EN
;

149 i(
ebiIn
->
bks
 & 
EBI_BANK3
)

151 

 &~(
_EBI_CTRL_BL3_MASK
|

152 
_EBI_CTRL_MODE3_MASK
|

153 
_EBI_CTRL_ARDY3EN_MASK
|

154 
_EBI_CTRL_ARDYTO3DIS_MASK
|

155 
_EBI_CTRL_NOIDLE3_MASK
|

156 
_EBI_CTRL_BANK3EN_MASK
);

157 

 |(
ebiIn
->
mode
 << 
_EBI_CTRL_MODE3_SHIFT
);

158 

 |(
ebiIn
->
dyEb
 << 
_EBI_CTRL_ARDY3EN_SHIFT
);

159 

 |(
ebiIn
->
dyDibTimeout
 << 
_EBI_CTRL_ARDYTO3DIS_SHIFT
);

160 

 |(
ebiIn
->
blEb
 << 
_EBI_CTRL_BL3_SHIFT
);

161 

 |(
ebiIn
->
noId
 << 
_EBI_CTRL_NOIDLE3_SHIFT
);

162 i
ebiIn
->
ab
)

164 

 |
EBI_CTRL_BANK3EN
;

168 

 &~(
_EBI_CTRL_MODE_MASK
|

169 
_EBI_CTRL_ARDYEN_MASK
|

170 
_EBI_CTRL_ARDYTODIS_MASK
|

171 
_EBI_CTRL_BANK0EN_MASK
|

172 
_EBI_CTRL_BANK1EN_MASK
|

173 
_EBI_CTRL_BANK2EN_MASK
|

174 
_EBI_CTRL_BANK3EN_MASK
);

175 i
ebiIn
->
ab
)

177 i
ebiIn
->
bks
 & 
EBI_BANK0
 )

179 

 |
EBI_CTRL_BANK0EN
;

181 i
ebiIn
->
bks
 & 
EBI_BANK1
 )

183 

 |
EBI_CTRL_BANK1EN
;

185 i
ebiIn
->
bks
 & 
EBI_BANK2
 )

187 

 |
EBI_CTRL_BANK2EN
;

189 i
ebiIn
->
bks
 & 
EBI_BANK3
 )

191 

 |
EBI_CTRL_BANK3EN
;

194 

 |
ebiIn
->
mode
;

195 

 |(
ebiIn
->
dyEb
 << 
_EBI_CTRL_ARDYEN_SHIFT
);

196 

 |(
ebiIn
->
dyDibTimeout
 << 
_EBI_CTRL_ARDYTODIS_SHIFT
);

200 #i
	`defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

201 
	`EBI_BkRdTimgS
(
ebiIn
->
bks
,

202 
ebiIn
->
adSupCyes
,

203 
ebiIn
->
adSobeCyes
,

204 
ebiIn
->
adHdCyes
);

205 
	`EBI_BkRdTimgCfig
(
ebiIn
->
bks
,

206 
ebiIn
->
adPageMode
,

207 
ebiIn
->
adPtch
,

208 
ebiIn
->
adHfRE
);

209 
	`EBI_BkWreTimgS
(
ebiIn
->
bks
,

210 
ebiIn
->
wreSupCyes
,

211 
ebiIn
->
wreSobeCyes
,

212 
ebiIn
->
wreHdCyes
);

213 
	`EBI_BkWreTimgCfig
(
ebiIn
->
bks
,

214 
ebiIn
->
wreBufrDib
,

215 
ebiIn
->
wreHfWE
);

216 
	`EBI_BkAddssTimgS
(
ebiIn
->
bks
,

217 
ebiIn
->
addrSupCyes
,

218 
ebiIn
->
addrHdCyes
);

219 
	`EBI_BkAddssTimgCfig
(
ebiIn
->
bks
,

220 
ebiIn
->
addrHfALE
);

222 
	`EBI_RdTimgS
(
ebiIn
->
adSupCyes
,

223 
ebiIn
->
adSobeCyes
,

224 
ebiIn
->
adHdCyes
);

225 
	`EBI_WreTimgS
(
ebiIn
->
wreSupCyes
,

226 
ebiIn
->
wreSobeCyes
,

227 
ebiIn
->
wreHdCyes
);

228 
	`EBI_AddssTimgS
(
ebiIn
->
addrSupCyes
,

229 
ebiIn
->
addrHdCyes
);

233 
EBI
->
CTRL
 = 

;

236 
ebiIn
->
mode
)

238 
ebiModeD16A16ALE
:

239 
ebiModeD8A24ALE
:

241 
	`BITBAND_Ph
(&(
EBI
->
ROUTE
), 
_EBI_ROUTE_ALEPEN_SHIFT
, 1);

243 #i
	`defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

244 
ebiModeD16
:

246 
ebiModeD8A8
:

248 
	`BITBAND_Ph
(&(
EBI
->
ROUTE
), 
_EBI_ROUTE_ALEPEN_SHIFT
, 0);

251 #i
	`defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

253 
EBI
->
ROUTE
 = (EBI->ROUTE & ~
_EBI_ROUTE_ALB_MASK
| 
ebiIn
->
aLow
;

254 
EBI
->
ROUTE
 = (EBI->ROUTE & ~
_EBI_ROUTE_APEN_MASK
| 
ebiIn
->
aHigh
;

256 
EBI
->
ROUTE
 = (EBI->ROUTE & ~
_EBI_ROUTE_LOCATION_MASK
| 
ebiIn
->
loti
;

259 if(

 & (
_EBI_CTRL_BL_MASK
|
_EBI_CTRL_BL1_MASK
|
_EBI_CTRL_BL2_MASK
|
_EBI_CTRL_BL3_MASK
))

261 
	`BITBAND_Ph
(&(
EBI
->
ROUTE
), 
_EBI_ROUTE_BLPEN_SHIFT
, 
ebiIn
->
blEb
);

265 
	`BITBAND_Ph
(&(
EBI
->
ROUTE
), 
_EBI_ROUTE_EBIPEN_SHIFT
, 1);

268 
	`EBI_ChSeEb
(
ebiIn
->
csLes
, 
ue
);

269 
	}
}

276 
	$EBI_Dib
()

279 
EBI
->
ROUTE
 = 
_EBI_ROUTE_RESETVALUE
;

281 
EBI
->
CTRL
 = 
_EBI_CTRL_RESETVALUE
;

282 
	}
}

295 
	$EBI_BkEb
(
ut32_t
 
bks
, 
bo
 
ab
)

297 i(
bks
 & 
EBI_BANK0
)

299 
	`BITBAND_Ph
(&(
EBI
->
CTRL
), 
_EBI_CTRL_BANK0EN_SHIFT
, 
ab
);

301 i(
bks
 & 
EBI_BANK1
)

303 
	`BITBAND_Ph
(&(
EBI
->
CTRL
), 
_EBI_CTRL_BANK1EN_SHIFT
, 
ab
);

305 i(
bks
 & 
EBI_BANK2
)

307 
	`BITBAND_Ph
(&(
EBI
->
CTRL
), 
_EBI_CTRL_BANK2EN_SHIFT
, 
ab
);

309 i(
bks
 & 
EBI_BANK3
)

311 
	`BITBAND_Ph
(&(
EBI
->
CTRL
), 
_EBI_CTRL_BANK3EN_SHIFT
, 
ab
);

313 
	}
}

326 
ut32_t
 
	$EBI_BkAddss
(
ut32_t
 
bk
)

328 #i
	`defed
 (
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

329 if(
EBI
->
CTRL
 & 
EBI_CTRL_ALTMAP
)

331 
bk
)

333 
EBI_BANK0
:

334 (
EBI_MEM_BASE
);

336 
EBI_BANK1
:

337 (
EBI_MEM_BASE
 + 0x10000000UL);

339 
EBI_BANK2
:

340 (
EBI_MEM_BASE
 + 0x20000000UL);

342 
EBI_BANK3
:

343 (
EBI_MEM_BASE
 + 0x30000000UL);

346 
	`EFM_ASSERT
(0);

351 
bk
)

353 
EBI_BANK0
:

354 (
EBI_MEM_BASE
);

356 
EBI_BANK1
:

357 (
EBI_MEM_BASE
 + 0x04000000UL);

359 
EBI_BANK2
:

360 (
EBI_MEM_BASE
 + 0x08000000UL);

362 
EBI_BANK3
:

363 (
EBI_MEM_BASE
 + 0x0C000000UL);

366 
	`EFM_ASSERT
(0);

370 
	}
}

383 
	$EBI_ChSeEb
(
ut32_t
 
cs
, 
bo
 
ab
)

385 i(
cs
 & 
EBI_CS0
)

387 
	`BITBAND_Ph
(&(
EBI
->
ROUTE
), 
_EBI_ROUTE_CS0PEN_SHIFT
, 
ab
);

389 i(
cs
 & 
EBI_CS1
)

391 
	`BITBAND_Ph
(&(
EBI
->
ROUTE
), 
_EBI_ROUTE_CS1PEN_SHIFT
, 
ab
);

393 i(
cs
 & 
EBI_CS2
)

395 
	`BITBAND_Ph
(&(
EBI
->
ROUTE
), 
_EBI_ROUTE_CS2PEN_SHIFT
, 
ab
);

397 i(
cs
 & 
EBI_CS3
)

399 
	`BITBAND_Ph
(&(
EBI
->
ROUTE
), 
_EBI_ROUTE_CS3PEN_SHIFT
, 
ab
);

401 
	}
}

414 
	$EBI_PެyS
(
EBI_Le_TyDef
 
le
, 
EBI_Pެy_TyDef
 
pެy
)

416 
le
)

418 
ebiLeARDY
:

419 
	`BITBAND_Ph
(&(
EBI
->
POLARITY
), 
_EBI_POLARITY_ARDYPOL_SHIFT
, 
pެy
);

421 
ebiLeALE
:

422 
	`BITBAND_Ph
(&(
EBI
->
POLARITY
), 
_EBI_POLARITY_ALEPOL_SHIFT
, 
pެy
);

424 
ebiLeWE
:

425 
	`BITBAND_Ph
(&(
EBI
->
POLARITY
), 
_EBI_POLARITY_WEPOL_SHIFT
, 
pެy
);

427 
ebiLeRE
:

428 
	`BITBAND_Ph
(&(
EBI
->
POLARITY
), 
_EBI_POLARITY_REPOL_SHIFT
, 
pެy
);

430 
ebiLeCS
:

431 
	`BITBAND_Ph
(&(
EBI
->
POLARITY
), 
_EBI_POLARITY_CSPOL_SHIFT
, 
pެy
);

433 #i
	`defed
 (
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

434 
ebiLeBL
:

435 
	`BITBAND_Ph
(&(
EBI
->
POLARITY
), 
_EBI_POLARITY_BLPOL_SHIFT
, 
pެy
);

437 
ebiLeTFTVSync
:

438 
	`BITBAND_Ph
(&(
EBI
->
TFTPOLARITY
), 
_EBI_TFTPOLARITY_VSYNCPOL_SHIFT
, 
pެy
);

440 
ebiLeTFTHSync
:

441 
	`BITBAND_Ph
(&(
EBI
->
TFTPOLARITY
), 
_EBI_TFTPOLARITY_HSYNCPOL_SHIFT
, 
pެy
);

443 
ebiLeTFTDaEn
:

444 
	`BITBAND_Ph
(&(
EBI
->
TFTPOLARITY
), 
_EBI_TFTPOLARITY_DATAENPOL_SHIFT
, 
pެy
);

446 
ebiLeTFTDClk
:

447 
	`BITBAND_Ph
(&(
EBI
->
TFTPOLARITY
), 
_EBI_TFTPOLARITY_DCLKPOL_SHIFT
, 
pެy
);

449 
ebiLeTFTCS
:

450 
	`BITBAND_Ph
(&(
EBI
->
TFTPOLARITY
), 
_EBI_TFTPOLARITY_CSPOL_SHIFT
, 
pެy
);

454 
	`EFM_ASSERT
(0);

457 
	}
}

474 
	$EBI_RdTimgS
(
tupCyes
, 
robeCyes
, 
hdCyes
)

476 
ut32_t
 
adTimg
;

479 
	`EFM_ASSERT
(
tupCyes
 < 4);

480 
	`EFM_ASSERT
(
robeCyes
 < 16);

481 
	`EFM_ASSERT
(
hdCyes
 < 4);

484 
adTimg
 = (
tupCyes
 << 
_EBI_RDTIMING_RDSETUP_SHIFT
) |

485 (
robeCyes
 << 
_EBI_RDTIMING_RDSTRB_SHIFT
) |

486 (
hdCyes
 << 
_EBI_RDTIMING_RDHOLD_SHIFT
);

489 
EBI
->
RDTIMING
 = (EBI->RDTIMING &

490 ~(
_EBI_RDTIMING_RDSETUP_MASK
 |

491 
_EBI_RDTIMING_RDSTRB_MASK
 |

492 
_EBI_RDTIMING_RDHOLD_MASK
)| 
adTimg
;

493 
	}
}

509 
	$EBI_WreTimgS
(
tupCyes
, 
robeCyes
, 
hdCyes
)

511 
ut32_t
 
wreTimg
;

514 
	`EFM_ASSERT
(
tupCyes
 < 4);

515 
	`EFM_ASSERT
(
robeCyes
 < 16);

516 
	`EFM_ASSERT
(
hdCyes
 < 4);

519 
wreTimg
 = (
tupCyes
 << 
_EBI_WRTIMING_WRSETUP_SHIFT
) |

520 (
robeCyes
 << 
_EBI_WRTIMING_WRSTRB_SHIFT
) |

521 (
hdCyes
 << 
_EBI_WRTIMING_WRHOLD_SHIFT
);

523 
EBI
->
WRTIMING
 = (EBI->WRTIMING &

524 ~(
_EBI_WRTIMING_WRSETUP_MASK
 |

525 
_EBI_WRTIMING_WRSTRB_MASK
 |

526 
_EBI_WRTIMING_WRHOLD_MASK
)| 
wreTimg
;

527 
	}
}

541 
	$EBI_AddssTimgS
(
tupCyes
, 
hdCyes
)

543 
ut32_t
 
addssLchTimg
;

546 
	`EFM_ASSERT
(
tupCyes
 < 4);

547 
	`EFM_ASSERT
(
hdCyes
 < 4);

550 
addssLchTimg
 = (
tupCyes
 << 
_EBI_ADDRTIMING_ADDRSETUP_SHIFT
) |

551 (
hdCyes
 << 
_EBI_ADDRTIMING_ADDRHOLD_SHIFT
);

553 
EBI
->
ADDRTIMING
 = (EBI->ADDRTIMING &

554 ~(
_EBI_ADDRTIMING_ADDRSETUP_MASK
 |

555 
_EBI_ADDRTIMING_ADDRHOLD_MASK
)| 
addssLchTimg
;

556 
	}
}

558 #i
defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

566 
	$EBI_TFTIn
(cڡ 
EBI_TFTIn_TyDef
 *
ebiTFTIn
)

568 
ut32_t
 

;

571 
	`EBI_TFTFmeBaS
(
ebiTFTIn
->
addssOfft
);

574 
	`EBI_TFTSizeS
(
ebiTFTIn
->
hsize
,

575 
ebiTFTIn
->
vsize
);

576 
	`EBI_TFTHPchS
(
ebiTFTIn
->
hPchFrt
,

577 
ebiTFTIn
->
hPchBack
,

578 
ebiTFTIn
->
hPulWidth
);

579 
	`EBI_TFTVPchS
(
ebiTFTIn
->
vPchFrt
,

580 
ebiTFTIn
->
vPchBack
,

581 
ebiTFTIn
->
vPulWidth
);

584 
	`EBI_TFTTimgS
(
ebiTFTIn
->
dkPiod
,

585 
ebiTFTIn
->
tPosi
,

586 
ebiTFTIn
->
tupCyes
,

587 
ebiTFTIn
->
hdCyes
);

590 
	`EBI_PެyS
(
ebiLeTFTCS
, 
ebiTFTIn
->
csPެy
);

591 
	`EBI_PެyS
(
ebiLeTFTDClk
, 
ebiTFTIn
->
dkPެy
);

592 
	`EBI_PެyS
(
ebiLeTFTDaEn
, 
ebiTFTIn
->
dnPެy
);

593 
	`EBI_PެyS
(
ebiLeTFTVSync
, 
ebiTFTIn
->
vsyncPެy
);

594 
	`EBI_PެyS
(
ebiLeTFTHSync
, 
ebiTFTIn
->
hsyncPެy
);

597 

 =

598 (
ut32_t
)(
ebiTFTIn
->
bk
) |

599 (
ut32_t
)(
ebiTFTIn
->
width
) |

600 (
ut32_t
)(
ebiTFTIn
->
cSrc
) |

601 (
ut32_t
)(
ebiTFTIn
->
ve
) |

602 (
ut32_t
)(
ebiTFTIn
->
fbTrigg
) |

603 (
ut32_t
)(
ebiTFTIn
->
shiDClk
 =
ue
 ? (1 << 
_EBI_TFTCTRL_SHIFTDCLKEN_SHIFT
) : 0) |

604 (
ut32_t
)(
ebiTFTIn
->
maskBnd
) |

605 (
ut32_t
)(
ebiTFTIn
->
driveMode
);

607 
EBI
->
TFTCTRL
 = 

;

610 i(
ebiTFTIn
->
driveMode
 !
ebiTFTDDModeDibd
)

612 
EBI
->
ROUTE
 |(
EBI_ROUTE_TFTPEN
);

614 
	}
}

626 
	$EBI_TFTSizeS
(
ut32_t
 
hizڏl
, ut32_
vtil
)

628 
	`EFM_ASSERT
((
hizڏl
-1) < 1024);

629 
	`EFM_ASSERT
((
vtil
-1) < 1024);

631 
EBI
->
TFTSIZE
 = ((
hizڏl
-1<< 
_EBI_TFTSIZE_HSZ_SHIFT
) |

632 ((
vtil
-1<< 
_EBI_TFTSIZE_VSZ_SHIFT
);

633 
	}
}

646 
	$EBI_TFTHPchS
(
t
, 
back
, 
pulWidth
)

648 
	`EFM_ASSERT
(
t
 < 256);

649 
	`EFM_ASSERT
(
back
 < 256);

650 
	`EFM_ASSERT
((
pulWidth
-1) < 128);

652 
EBI
->
TFTHPORCH
 = (
t
 << 
_EBI_TFTHPORCH_HFPORCH_SHIFT
) |

653 (
back
 << 
_EBI_TFTHPORCH_HBPORCH_SHIFT
) |

654 ((
pulWidth
-1<< 
_EBI_TFTHPORCH_HSYNC_SHIFT
);

655 
	}
}

669 
	$EBI_TFTVPchS
(
t
, 
back
, 
pulWidth
)

671 
	`EFM_ASSERT
(
t
 < 256);

672 
	`EFM_ASSERT
(
back
 < 256);

673 
	`EFM_ASSERT
((
pulWidth
-1) < 128);

675 
EBI
->
TFTVPORCH
 = (
t
 << 
_EBI_TFTVPORCH_VFPORCH_SHIFT
) |

676 (
back
 << 
_EBI_TFTVPORCH_VBPORCH_SHIFT
) |

677 ((
pulWidth
-1<< 
_EBI_TFTVPORCH_VSYNC_SHIFT
);

678 
	}
}

697 
	$EBI_TFTTimgS
(
dkPiod
, 
t
, 
tup
, 
hd
)

699 
	`EFM_ASSERT
(
dkPiod
 < 2048);

700 
	`EFM_ASSERT
(
t
 < 2048);

701 
	`EFM_ASSERT
(
tup
 < 4);

702 
	`EFM_ASSERT
(
hd
 < 4);

704 
EBI
->
TFTTIMING
 = (
dkPiod
 << 
_EBI_TFTTIMING_DCLKPERIOD_SHIFT
) |

705 (
t
 << 
_EBI_TFTTIMING_TFTSTART_SHIFT
) |

706 (
tup
 << 
_EBI_TFTTIMING_TFTSETUP_SHIFT
) |

707 (
hd
 << 
_EBI_TFTTIMING_TFTHOLD_SHIFT
);

708 
	}
}

711 #i
defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

728 
	$EBI_BkRdTimgCfig
(
ut32_t
 
bks
, 
bo
 
geMode
, bo 
etch
, bo 
hfRE
)

731 
	`EFM_ASSERT
((
bks
 & ~(
EBI_BANK0
 | 
EBI_BANK1
 | 
EBI_BANK2
 | 
EBI_BANK3
)) == 0);

734 if
bks
 & 
EBI_BANK0
 )

736 
	`BITBAND_Ph
(&
EBI
->
RDTIMING
, 
_EBI_RDTIMING_PAGEMODE_SHIFT
, 
geMode
);

737 
	`BITBAND_Ph
(&
EBI
->
RDTIMING
, 
_EBI_RDTIMING_PREFETCH_SHIFT
, 
etch
);

738 
	`BITBAND_Ph
(&
EBI
->
RDTIMING
, 
_EBI_RDTIMING_HALFRE_SHIFT
, 
hfRE
);

740 if
bks
 & 
EBI_BANK1
 )

742 
	`BITBAND_Ph
(&
EBI
->
RDTIMING1
, 
_EBI_RDTIMING_PAGEMODE_SHIFT
, 
geMode
);

743 
	`BITBAND_Ph
(&
EBI
->
RDTIMING1
, 
_EBI_RDTIMING_PREFETCH_SHIFT
, 
etch
);

744 
	`BITBAND_Ph
(&
EBI
->
RDTIMING1
, 
_EBI_RDTIMING_HALFRE_SHIFT
, 
hfRE
);

746 if
bks
 & 
EBI_BANK2
 )

748 
	`BITBAND_Ph
(&
EBI
->
RDTIMING2
, 
_EBI_RDTIMING_PAGEMODE_SHIFT
, 
geMode
);

749 
	`BITBAND_Ph
(&
EBI
->
RDTIMING2
, 
_EBI_RDTIMING_PREFETCH_SHIFT
, 
etch
);

750 
	`BITBAND_Ph
(&
EBI
->
RDTIMING2
, 
_EBI_RDTIMING_HALFRE_SHIFT
, 
hfRE
);

752 if
bks
 & 
EBI_BANK3
 )

754 
	`BITBAND_Ph
(&
EBI
->
RDTIMING3
, 
_EBI_RDTIMING_PAGEMODE_SHIFT
, 
geMode
);

755 
	`BITBAND_Ph
(&
EBI
->
RDTIMING3
, 
_EBI_RDTIMING_PREFETCH_SHIFT
, 
etch
);

756 
	`BITBAND_Ph
(&
EBI
->
RDTIMING3
, 
_EBI_RDTIMING_HALFRE_SHIFT
, 
hfRE
);

758 
	}
}

777 
	$EBI_BkRdTimgS
(
ut32_t
 
bks
, 
tupCyes
, 
robeCyes
, 
hdCyes
)

779 
ut32_t
 
adTimg
;

782 
	`EFM_ASSERT
((
bks
 & ~(
EBI_BANK0
 | 
EBI_BANK1
 | 
EBI_BANK2
 | 
EBI_BANK3
)) == 0);

785 
	`EFM_ASSERT
(
tupCyes
 < 4);

786 
	`EFM_ASSERT
(
robeCyes
 < 64);

787 
	`EFM_ASSERT
(
hdCyes
 < 4);

790 
adTimg
 = (
tupCyes
 << 
_EBI_RDTIMING_RDSETUP_SHIFT
) |

791 (
robeCyes
 << 
_EBI_RDTIMING_RDSTRB_SHIFT
) |

792 (
hdCyes
 << 
_EBI_RDTIMING_RDHOLD_SHIFT
);

794 i(
bks
 & 
EBI_BANK0
)

796 
EBI
->
RDTIMING
 = (EBI->RDTIMING &

797 ~(
_EBI_RDTIMING_RDSETUP_MASK
 |

798 
_EBI_RDTIMING_RDSTRB_MASK
 |

799 
_EBI_RDTIMING_RDHOLD_MASK
)| 
adTimg
;

801 i(
bks
 & 
EBI_BANK1
)

803 
EBI
->
RDTIMING1
 = (EBI->RDTIMING1 &

804 ~(
_EBI_RDTIMING1_RDSETUP_MASK
 |

805 
_EBI_RDTIMING1_RDSTRB_MASK
 |

806 
_EBI_RDTIMING1_RDHOLD_MASK
)| 
adTimg
;

808 i(
bks
 & 
EBI_BANK2
)

810 
EBI
->
RDTIMING2
 = (EBI->RDTIMING2 &

811 ~(
_EBI_RDTIMING2_RDSETUP_MASK
 |

812 
_EBI_RDTIMING2_RDSTRB_MASK
 |

813 
_EBI_RDTIMING2_RDHOLD_MASK
)| 
adTimg
;

815 i(
bks
 & 
EBI_BANK3
)

817 
EBI
->
RDTIMING3
 = (EBI->RDTIMING3 &

818 ~(
_EBI_RDTIMING3_RDSETUP_MASK
 |

819 
_EBI_RDTIMING3_RDSTRB_MASK
 |

820 
_EBI_RDTIMING3_RDHOLD_MASK
)| 
adTimg
;

822 
	}
}

838 
	$EBI_BkWreTimgCfig
(
ut32_t
 
bks
, 
bo
 
wreBufDib
, bo 
hfWE
)

841 
	`EFM_ASSERT
((
bks
 & ~(
EBI_BANK0
 | 
EBI_BANK1
 | 
EBI_BANK2
 | 
EBI_BANK3
)) == 0);

844 if
bks
 & 
EBI_BANK0
 )

846 
	`BITBAND_Ph
(&
EBI
->
WRTIMING
, 
_EBI_WRTIMING_WBUFDIS_SHIFT
, 
wreBufDib
);

847 
	`BITBAND_Ph
(&
EBI
->
WRTIMING
, 
_EBI_WRTIMING_HALFWE_SHIFT
, 
hfWE
);

849 if
bks
 & 
EBI_BANK1
 )

851 
	`BITBAND_Ph
(&
EBI
->
WRTIMING1
, 
_EBI_WRTIMING_WBUFDIS_SHIFT
, 
wreBufDib
);

852 
	`BITBAND_Ph
(&
EBI
->
WRTIMING1
, 
_EBI_WRTIMING_HALFWE_SHIFT
, 
hfWE
);

854 if
bks
 & 
EBI_BANK2
 )

856 
	`BITBAND_Ph
(&
EBI
->
WRTIMING2
, 
_EBI_WRTIMING_WBUFDIS_SHIFT
, 
wreBufDib
);

857 
	`BITBAND_Ph
(&
EBI
->
WRTIMING2
, 
_EBI_WRTIMING_HALFWE_SHIFT
, 
hfWE
);

859 if
bks
 & 
EBI_BANK3
 )

861 
	`BITBAND_Ph
(&
EBI
->
WRTIMING3
, 
_EBI_WRTIMING_WBUFDIS_SHIFT
, 
wreBufDib
);

862 
	`BITBAND_Ph
(&
EBI
->
WRTIMING3
, 
_EBI_WRTIMING_HALFWE_SHIFT
, 
hfWE
);

864 
	}
}

883 
	$EBI_BkWreTimgS
(
ut32_t
 
bks
, 
tupCyes
, 
robeCyes
, 
hdCyes
)

885 
ut32_t
 
wreTimg
;

888 
	`EFM_ASSERT
((
bks
 & ~(
EBI_BANK0
 | 
EBI_BANK1
 | 
EBI_BANK2
 | 
EBI_BANK3
)) == 0);

891 
	`EFM_ASSERT
(
tupCyes
 < 4);

892 
	`EFM_ASSERT
(
robeCyes
 < 64);

893 
	`EFM_ASSERT
(
hdCyes
 < 4);

896 
wreTimg
 = (
tupCyes
 << 
_EBI_WRTIMING_WRSETUP_SHIFT
) |

897 (
robeCyes
 << 
_EBI_WRTIMING_WRSTRB_SHIFT
) |

898 (
hdCyes
 << 
_EBI_WRTIMING_WRHOLD_SHIFT
);

900 i(
bks
 & 
EBI_BANK0
)

902 
EBI
->
WRTIMING
 = (EBI->WRTIMING &

903 ~(
_EBI_WRTIMING_WRSETUP_MASK
 |

904 
_EBI_WRTIMING_WRSTRB_MASK
 |

905 
_EBI_WRTIMING_WRHOLD_MASK
)| 
wreTimg
;

907 i(
bks
 & 
EBI_BANK1
)

909 
EBI
->
WRTIMING1
 = (EBI->WRTIMING1 &

910 ~(
_EBI_WRTIMING1_WRSETUP_MASK
 |

911 
_EBI_WRTIMING1_WRSTRB_MASK
 |

912 
_EBI_WRTIMING1_WRHOLD_MASK
)| 
wreTimg
;

914 i(
bks
 & 
EBI_BANK2
)

916 
EBI
->
WRTIMING2
 = (EBI->WRTIMING2 &

917 ~(
_EBI_WRTIMING2_WRSETUP_MASK
 |

918 
_EBI_WRTIMING2_WRSTRB_MASK
 |

919 
_EBI_WRTIMING2_WRHOLD_MASK
)| 
wreTimg
;

921 i(
bks
 & 
EBI_BANK3
)

923 
EBI
->
WRTIMING3
 = (EBI->WRTIMING3 &

924 ~(
_EBI_WRTIMING3_WRSETUP_MASK
 |

925 
_EBI_WRTIMING3_WRSTRB_MASK
 |

926 
_EBI_WRTIMING3_WRHOLD_MASK
)| 
wreTimg
;

928 
	}
}

941 
	$EBI_BkAddssTimgCfig
(
ut32_t
 
bks
, 
bo
 
hfALE
)

944 
	`EFM_ASSERT
((
bks
 & ~(
EBI_BANK0
 | 
EBI_BANK1
 | 
EBI_BANK2
 | 
EBI_BANK3
)) == 0);

946 if
bks
 & 
EBI_BANK0
 )

948 
	`BITBAND_Ph
(&
EBI
->
ADDRTIMING
, 
_EBI_ADDRTIMING_HALFALE_SHIFT
, 
hfALE
);

950 if
bks
 & 
EBI_BANK1
 )

952 
	`BITBAND_Ph
(&
EBI
->
ADDRTIMING1
, 
_EBI_ADDRTIMING_HALFALE_SHIFT
, 
hfALE
);

954 if
bks
 & 
EBI_BANK2
 )

956 
	`BITBAND_Ph
(&
EBI
->
ADDRTIMING2
, 
_EBI_ADDRTIMING_HALFALE_SHIFT
, 
hfALE
);

958 if
bks
 & 
EBI_BANK3
 )

960 
	`BITBAND_Ph
(&
EBI
->
ADDRTIMING3
, 
_EBI_ADDRTIMING_HALFALE_SHIFT
, 
hfALE
);

962 
	}
}

979 
	$EBI_BkAddssTimgS
(
ut32_t
 
bks
, 
tupCyes
, 
hdCyes
)

981 
ut32_t
 
addssLchTimg
;

984 
	`EFM_ASSERT
((
bks
 & ~(
EBI_BANK0
 | 
EBI_BANK1
 | 
EBI_BANK2
 | 
EBI_BANK3
)) == 0);

987 
	`EFM_ASSERT
(
tupCyes
 < 4);

988 
	`EFM_ASSERT
(
hdCyes
 < 4);

991 
addssLchTimg
 = (
tupCyes
 << 
_EBI_ADDRTIMING_ADDRSETUP_SHIFT
) |

992 (
hdCyes
 << 
_EBI_ADDRTIMING_ADDRHOLD_SHIFT
);

994 i(
bks
 & 
EBI_BANK0
)

996 
EBI
->
ADDRTIMING
 = (EBI->ADDRTIMING &

997 ~(
_EBI_ADDRTIMING_ADDRSETUP_MASK
 |

998 
_EBI_ADDRTIMING_ADDRHOLD_MASK
)| 
addssLchTimg
;

1000 i(
bks
 & 
EBI_BANK1
)

1002 
EBI
->
ADDRTIMING1
 = (EBI->ADDRTIMING1 &

1003 ~(
_EBI_ADDRTIMING1_ADDRSETUP_MASK
 |

1004 
_EBI_ADDRTIMING1_ADDRHOLD_MASK
)| 
addssLchTimg
;

1006 i(
bks
 & 
EBI_BANK2
)

1008 
EBI
->
ADDRTIMING2
 = (EBI->ADDRTIMING2 &

1009 ~(
_EBI_ADDRTIMING2_ADDRSETUP_MASK
 |

1010 
_EBI_ADDRTIMING2_ADDRHOLD_MASK
)| 
addssLchTimg
;

1012 i(
bks
 & 
EBI_BANK3
)

1014 
EBI
->
ADDRTIMING3
 = (EBI->ADDRTIMING3 &

1015 ~(
_EBI_ADDRTIMING3_ADDRSETUP_MASK
 |

1016 
_EBI_ADDRTIMING3_ADDRHOLD_MASK
)| 
addssLchTimg
;

1018 
	}
}

1035 
	$EBI_BkPެyS
(
ut32_t
 
bks
, 
EBI_Le_TyDef
 
le
, 
EBI_Pެy_TyDef
 
pެy
)

1037 
ut32_t
 
bkS
 = 0;

1038 vީ
ut32_t
 *
pRegi
 = 0;

1041 
	`EFM_ASSERT
((
bks
 & ~(
EBI_BANK0
 | 
EBI_BANK1
 | 
EBI_BANK2
 | 
EBI_BANK3
)) == 0);

1043 
bks
)

1045 #i
	`defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

1046 i(
bks
 & 
EBI_BANK0
)

1048 
pRegi
 = &
EBI
->
POLARITY
;

1049 
bkS
 = 
EBI_BANK0
;

1051 i(
bks
 & 
EBI_BANK1
)

1053 
pRegi
 = &
EBI
->
POLARITY1
;

1054 
bkS
 = 
EBI_BANK1
;

1056 i(
bks
 & 
EBI_BANK2
)

1058 
pRegi
 = &
EBI
->
POLARITY2
;

1059 
bkS
 = 
EBI_BANK2
;

1061 i(
bks
 & 
EBI_BANK3
)

1063 
pRegi
 = &
EBI
->
POLARITY3
;

1064 
bkS
 = 
EBI_BANK3
;

1067 
pRegi
 = &
EBI
->
POLARITY
;

1068 
bks
 = 0;

1072 
le
)

1074 
ebiLeARDY
:

1075 
	`BITBAND_Ph
(
pRegi
, 
_EBI_POLARITY_ARDYPOL_SHIFT
, 
pެy
);

1077 
ebiLeALE
:

1078 
	`BITBAND_Ph
(
pRegi
, 
_EBI_POLARITY_ALEPOL_SHIFT
, 
pެy
);

1080 
ebiLeWE
:

1081 
	`BITBAND_Ph
(
pRegi
, 
_EBI_POLARITY_WEPOL_SHIFT
, 
pެy
);

1083 
ebiLeRE
:

1084 
	`BITBAND_Ph
(
pRegi
, 
_EBI_POLARITY_REPOL_SHIFT
, 
pެy
);

1086 
ebiLeCS
:

1087 
	`BITBAND_Ph
(
pRegi
, 
_EBI_POLARITY_CSPOL_SHIFT
, 
pެy
);

1089 #i
	`defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

1090 
ebiLeBL
:

1091 
	`BITBAND_Ph
(
pRegi
, 
_EBI_POLARITY_BLPOL_SHIFT
, 
pެy
);

1093 
ebiLeTFTVSync
:

1094 
	`BITBAND_Ph
(&(
EBI
->
TFTPOLARITY
), 
_EBI_TFTPOLARITY_VSYNCPOL_SHIFT
, 
pެy
);

1096 
ebiLeTFTHSync
:

1097 
	`BITBAND_Ph
(&(
EBI
->
TFTPOLARITY
), 
_EBI_TFTPOLARITY_HSYNCPOL_SHIFT
, 
pެy
);

1099 
ebiLeTFTDaEn
:

1100 
	`BITBAND_Ph
(&(
EBI
->
TFTPOLARITY
), 
_EBI_TFTPOLARITY_DATAENPOL_SHIFT
, 
pެy
);

1102 
ebiLeTFTDClk
:

1103 
	`BITBAND_Ph
(&(
EBI
->
TFTPOLARITY
), 
_EBI_TFTPOLARITY_DCLKPOL_SHIFT
, 
pެy
);

1105 
ebiLeTFTCS
:

1106 
	`BITBAND_Ph
(&(
EBI
->
TFTPOLARITY
), 
_EBI_TFTPOLARITY_CSPOL_SHIFT
, 
pެy
);

1110 
	`EFM_ASSERT
(0);

1113 
bks
 = bk& (~
bkS
);

1115 
	}
}

1129 
	$EBI_BkByLeEb
(
ut32_t
 
bks
, 
bo
 
ab
)

1132 
	`EFM_ASSERT
((
bks
 & ~(
EBI_BANK0
 | 
EBI_BANK1
 | 
EBI_BANK2
 | 
EBI_BANK3
)) == 0);

1135 i(
bks
 & 
EBI_BANK0
)

1137 
	`BITBAND_Ph
(&(
EBI
->
CTRL
), 
_EBI_CTRL_BL_SHIFT
, 
ab
);

1139 i(
bks
 & 
EBI_BANK1
)

1141 
	`BITBAND_Ph
(&(
EBI
->
CTRL
), 
_EBI_CTRL_BL1_SHIFT
, 
ab
);

1143 i(
bks
 & 
EBI_BANK2
)

1145 
	`BITBAND_Ph
(&(
EBI
->
CTRL
), 
_EBI_CTRL_BL2_SHIFT
, 
ab
);

1147 i(
bks
 & 
EBI_BANK3
)

1149 
	`BITBAND_Ph
(&(
EBI
->
CTRL
), 
_EBI_CTRL_BL3_SHIFT
, 
ab
);

1151 
	}
}

1162 
	$EBI_AMEb
(
bo
 
ab
)

1164 
	`BITBAND_Ph
(&(
EBI
->
CTRL
), 
_EBI_CTRL_ALTMAP_SHIFT
, 
ab
);

1165 
	}
}

	@C:\Users\Alexander\AppData\Roaming\energymicro\emlib\src\em_emu.c

33 
	~"em_emu.h
"

34 
	~"em_cmu.h
"

35 
	~"em_as.h
"

50 #i(
CMU_STATUS_AUXHFRCOENS
 !
CMU_OSCENCMD_AUXHFRCOEN
)

51 #r 
Ci
 

 
AUXHFRCOENS
 
d
 
AUXHFRCOEN
 
bposis


53 #i(
CMU_STATUS_HFXOENS
 !
CMU_OSCENCMD_HFXOEN
)

54 #r 
Ci
 

 
HFXOENS
 
d
 
HFXOEN
 
bposis


56 #i(
CMU_STATUS_LFRCOENS
 !
CMU_OSCENCMD_LFRCOEN
)

57 #r 
Ci
 

 
LFRCOENS
 
d
 
LFRCOEN
 
bposis


59 #i(
CMU_STATUS_LFXOENS
 !
CMU_OSCENCMD_LFXOEN
)

60 #r 
Ci
 

 
LFXOENS
 
d
 
LFXOEN
 
bposis


77 
ut16_t
 
	gcmuStus
;

91 
	$EMU_Ree
()

93 
ut32_t
 
cmuLocked
;

99 
cmuLocked
 = 
CMU
->
LOCK
 & 
CMU_LOCK_LOCKKEY_LOCKED
;

100 
	`CMU_Uock
();

106 
CMU
->
OSCENCMD
 = 
cmuStus
 & (
CMU_STATUS_AUXHFRCOENS
 |

107 
CMU_STATUS_HFXOENS
 |

108 
CMU_STATUS_LFRCOENS
 |

109 
CMU_STATUS_LFXOENS
);

112 
cmuStus
 & (
CMU_STATUS_HFXOSEL
 | 
CMU_STATUS_HFRCOSEL
 |

113 
CMU_STATUS_LFXOSEL
 | 
CMU_STATUS_LFRCOSEL
))

115 
CMU_STATUS_LFRCOSEL
:

117 !(
CMU
->
STATUS
 & 
CMU_STATUS_LFRCORDY
))

119 
CMU
->
CMD
 = 
CMU_CMD_HFCLKSEL_LFRCO
;

122 
CMU_STATUS_LFXOSEL
:

124 !(
CMU
->
STATUS
 & 
CMU_STATUS_LFXORDY
))

126 
CMU
->
CMD
 = 
CMU_CMD_HFCLKSEL_LFXO
;

129 
CMU_STATUS_HFXOSEL
:

131 !(
CMU
->
STATUS
 & 
CMU_STATUS_HFXORDY
))

133 
CMU
->
CMD
 = 
CMU_CMD_HFCLKSEL_HFXO
;

144 i! (
cmuStus
 & 
CMU_STATUS_HFRCOENS
) )

146 
CMU
->
OSCENCMD
 = 
CMU_OSCENCMD_HFRCODIS
;

150 i(
cmuLocked
)

152 
	`CMU_Lock
();

154 
	}
}

204 
	$EMU_EEM2
(
bo
 
e
)

208 
cmuStus
 = (
ut16_t
)(
CMU
->
STATUS
);

211 
SCB
->
SCR
 |
SCB_SCR_SLEEPDEEP_Msk
;

212 
	`__WFI
();

215 i(
e
)

217 
	`EMU_Ree
();

222 i(!(
cmuStus
 & 
CMU_STATUS_HFRCOSEL
))

224 
	`SyemCeClockUpde
();

226 
	}
}

271 
	$EMU_EEM3
(
bo
 
e
)

273 
ut32_t
 
cmuLocked
;

277 
cmuStus
 = (
ut16_t
)(
CMU
->
STATUS
);

280 
cmuLocked
 = 
CMU
->
LOCK
 & 
CMU_LOCK_LOCKKEY_LOCKED
;

281 
	`CMU_Uock
();

284 
CMU
->
OSCENCMD
 = 
CMU_OSCENCMD_LFXODIS
 | 
CMU_OSCENCMD_LFRCODIS
;

287 i(
cmuLocked
)

289 
	`CMU_Lock
();

293 
SCB
->
SCR
 |
SCB_SCR_SLEEPDEEP_Msk
;

294 
	`__WFI
();

297 i(
e
)

299 
	`EMU_Ree
();

304 i(!(
cmuStus
 & 
CMU_STATUS_HFRCOSEL
))

306 
	`SyemCeClockUpde
();

308 
	}
}

318 
	$EMU_EEM4
()

320 
i
;

323 
EMU
->
LOCK
 = 
EMU_LOCK_LOCKKEY_UNLOCK
;

325 
i
 = 0; i < 4; i++)

327 
EMU
->
CTRL
 = (2 << 
_EMU_CTRL_EM4CTRL_SHIFT
);

328 
EMU
->
CTRL
 = (3 << 
_EMU_CTRL_EM4CTRL_SHIFT
);

330 
EMU
->
CTRL
 = (2 << 
_EMU_CTRL_EM4CTRL_SHIFT
);

331 
	}
}

349 
	$EMU_MemPwrDown
(
ut32_t
 
blocks
)

351 #i
	`defed
(
_EMU_MEMCTRL_RESETVALUE
)

352 
	`EFM_ASSERT
(
blocks
 <
_EMU_MEMCTRL_MASK
);

354 
EMU
->
MEMCTRL
 = 
blocks
;

356 ()
blocks
;

358 
	}
}

380 
	$EMU_UpdeOscCfig
()

383 
cmuStus
 = (
ut16_t
)(
CMU
->
STATUS
);

384 
	}
}

387 #i
defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

395 
	$EMU_EM4In
(
EMU_EM4In_TyDef
 *
em4
)

397 
ut32_t
 
em4cf
 = 
EMU
->
EM4CONF
;

400 
em4cf
 &= ~(

401 
_EMU_EM4CONF_LOCKCONF_MASK
|

402 
_EMU_EM4CONF_OSC_MASK
|

403 
_EMU_EM4CONF_BURTCWU_MASK
|

404 
_EMU_EM4CONF_VREGEN_MASK
);

407 
em4cf
 |= (

408 (
em4
->
lockCfig
 << 
_EMU_EM4CONF_LOCKCONF_SHIFT
)|

409 (
em4
->
osc
)|

410 (
em4
->
buRtcWakeup
 << 
_EMU_EM4CONF_BURTCWU_SHIFT
)|

411 (
em4
->
vg
 << 
_EMU_EM4CONF_VREGEN_SHIFT
));

414 
EMU
->
EM4CONF
 = 
em4cf
;

415 
	}
}

425 
	$EMU_BUPDIn
(
EMU_BUPDIn_TyDef
 *
bupdIn
)

427 
ut32_t
 
g
;

430 
g
 = 
EMU
->
PWRCONF
 & ~(

431 
_EMU_PWRCONF_PWRRES_MASK
|

432 
_EMU_PWRCONF_VOUTSTRONG_MASK
|

433 
_EMU_PWRCONF_VOUTMED_MASK
|

434 
_EMU_PWRCONF_VOUTWEAK_MASK
);

436 
g
 |(
bupdIn
->
si
|

437 (
bupdIn
->
voutSg
 << 
_EMU_PWRCONF_VOUTSTRONG_SHIFT
)|

438 (
bupdIn
->
voutMed
 << 
_EMU_PWRCONF_VOUTMED_SHIFT
)|

439 (
bupdIn
->
voutWk
 << 
_EMU_PWRCONF_VOUTWEAK_SHIFT
));

441 
EMU
->
PWRCONF
 = 
g
;

444 
g
 = 
EMU
->
BUINACT
 & ~(
_EMU_BUINACT_PWRCON_MASK
);

445 
g
 |(
bupdIn
->
aivePow
);

446 
EMU
->
BUINACT
 = 
g
;

449 
g
 = 
EMU
->
BUACT
 & ~(
_EMU_BUACT_PWRCON_MASK
);

450 
g
 |(
bupdIn
->
aivePow
);

451 
EMU
->
BUACT
 = 
g
;

454 
g
 = 
EMU
->
BUCTRL
 & ~(

455 
_EMU_BUCTRL_PROBE_MASK
|

456 
_EMU_BUCTRL_BODCAL_MASK
|

457 
_EMU_BUCTRL_STATEN_MASK
|

458 
_EMU_BUCTRL_EN_MASK
);

462 
g
 |(
bupdIn
->
obe
|

463 (
bupdIn
->
bodC
 << 
_EMU_BUCTRL_BODCAL_SHIFT
)|

464 (
bupdIn
->
usPEb
 << 
_EMU_BUCTRL_STATEN_SHIFT
)|

465 (
bupdIn
->
ab
 << 
_EMU_BUCTRL_EN_SHIFT
));

468 
EMU
->
BUCTRL
 = 
g
;

471 
	`EMU_BUPEb
(
bupdIn
->
ab
);

474 
	`BITBAND_Ph
(&(
RMU
->
CTRL
), 
_RMU_CTRL_BURSTEN_SHIFT
, !
bupdIn
->
ab
);

475 
	}
}

486 
	$EMU_BUThshdS
(
EMU_BODMode_TyDef
 
mode
, 
ut32_t
 
vue
)

488 
	`EFM_ASSERT
(
vue
<4);

490 
mode
)

492 
emuBODMode_Aive
:

493 
EMU
->
BUACT
 = (EMU->BUACT & ~(
_EMU_BUACT_BUEXTHRES_MASK
))|(
vue
<<
_EMU_BUACT_BUEXTHRES_SHIFT
);

495 
emuBODMode_Iive
:

496 
EMU
->
BUINACT
 = (EMU->BUINACT & ~(
_EMU_BUINACT_BUENTHRES_MASK
))|(
vue
<<
_EMU_BUINACT_BUENTHRES_SHIFT
);

499 
	}
}

510 
	$EMU_BUThsRgeS
(
EMU_BODMode_TyDef
 
mode
, 
ut32_t
 
vue
)

512 
	`EFM_ASSERT
(
vue
<4);

514 
mode
)

516 
emuBODMode_Aive
:

517 
EMU
->
BUACT
 = (EMU->BUACT & ~(
_EMU_BUACT_BUEXRANGE_MASK
))|(
vue
<<
_EMU_BUACT_BUEXRANGE_SHIFT
);

519 
emuBODMode_Iive
:

520 
EMU
->
BUINACT
 = (EMU->BUINACT & ~(
_EMU_BUINACT_BUENRANGE_MASK
))|(
vue
<<
_EMU_BUINACT_BUENRANGE_SHIFT
);

523 
	}
}

	@C:\Users\Alexander\AppData\Roaming\energymicro\emlib\src\em_gpio.c

34 
	~"em_gpio.h
"

35 
	~"em_bbd.h
"

36 
	~"em_as.h
"

56 
	#GPIO_DRIVEMODE_VALID
(
mode
((mode<3)

	)

75 
	$GPIO_DbgLotiS
(
loti
)

77 
	`EFM_ASSERT
(
loti
 < 
AFCHANLOC_MAX
);

79 
GPIO
->
ROUTE
 = (GPIO->ROUTE & ~
_GPIO_ROUTE_SWLOCATION_MASK
) |

80 (
loti
 << 
_GPIO_ROUTE_SWLOCATION_SHIFT
);

81 
	}
}

94 
	$GPIO_DriveModeS
(
GPIO_Pt_TyDef
 
pt
, 
GPIO_DriveMode_TyDef
 
mode
)

96 
	`EFM_ASSERT
(
	`GPIO_PORT_VALID
(
pt
&& 
	`GPIO_DRIVEMODE_VALID
(
mode
));

98 
GPIO
->
P
[
pt
].
CTRL
 = (GPIO->P[pt].CTRL & ~(
_GPIO_P_CTRL_DRIVEMODE_MASK
))

99 | (
mode
 << 
_GPIO_P_CTRL_DRIVEMODE_SHIFT
);

100 
	}
}

139 
	$GPIO_ICfig
(
GPIO_Pt_TyDef
 
pt
,

140 
p
,

141 
bo
 
risgEdge
,

142 
bo
 
ΚgEdge
,

143 
bo
 
ab
)

145 
ut32_t
 
tmp
;

147 
	`EFM_ASSERT
(
	`GPIO_PORT_VALID
(
pt
&& 
	`GPIO_PIN_VALID
(
p
));

152 i(
p
 < 8)

154 
GPIO
->
EXTIPSELL
 = (GPIO->EXTIPSELL & ~(0xF << (4 * 
p
))) |

155 (
pt
 << (4 * 
p
));

159 
tmp
 = 
p
 - 8;

160 
GPIO
->
EXTIPSELH
 = (GPIO->EXTIPSELH & ~(0xF << (4 * 
tmp
))) |

161 (
pt
 << (4 * 
tmp
));

165 
	`BITBAND_Ph
(&(
GPIO
->
EXTIRISE
), 
p
, ()
risgEdge
);

168 
	`BITBAND_Ph
(&(
GPIO
->
EXTIFALL
), 
p
, ()
ΚgEdge
);

171 
GPIO
->
IFC
 = 1 << 
p
;

174 
	`BITBAND_Ph
(&(
GPIO
->
IEN
), 
p
, ()
ab
);

175 
	}
}

195 
	$GPIO_PModeS
(
GPIO_Pt_TyDef
 
pt
,

196 
p
,

197 
GPIO_Mode_TyDef
 
mode
,

198 
out
)

200 
	`EFM_ASSERT
(
	`GPIO_PORT_VALID
(
pt
&& 
	`GPIO_PIN_VALID
(
p
));

204 i(
mode
 !
gpioModeDibd
)

206 i(
out
)

208 
GPIO
->
P
[
pt
].
DOUTSET
 = 1 << 
p
;

212 
GPIO
->
P
[
pt
].
DOUTCLR
 = 1 << 
p
;

218 i(
p
 < 8)

220 
GPIO
->
P
[
pt
].
MODEL
 = (GPIO->P[pt].MODEL & ~(0xF << (
p
 * 4))) |

221 (
mode
 << (
p
 * 4));

225 
GPIO
->
P
[
pt
].
MODEH
 = (GPIO->P[pt].MODEH & ~(0xF << ((
p
 - 8) * 4))) |

226 (
mode
 << ((
p
 - 8) * 4));

229 i(
mode
 =
gpioModeDibd
)

231 i(
out
)

233 
GPIO
->
P
[
pt
].
DOUTSET
 = 1 << 
p
;

237 
GPIO
->
P
[
pt
].
DOUTCLR
 = 1 << 
p
;

240 
	}
}

	@C:\Users\Alexander\AppData\Roaming\energymicro\emlib\src\em_lcd.c

33 
	~"em_lcd.h
"

34 #i
defed
(
LCD_COUNT
) && (LCD_COUNT > 0)

35 
	~"em_as.h
"

36 
	~"em_bbd.h
"

62 
	$LCD_In
(cڡ 
LCD_In_TyDef
 *
lcdIn
)

64 
ut32_t
 
diCl
 = 
LCD
->
DISPCTRL
;

66 
	`EFM_ASSERT
(
lcdIn
 != (*) 0);

69 
	`LCD_Eb
(
l
);

72 
diCl
 &= ~(

73 #i
	`defed
(
_EFM32_TINY_FAMILY
|| defed(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

74 
_LCD_DISPCTRL_MUXE_MASK
 |

76 
_LCD_DISPCTRL_MUX_MASK
 |

77 
_LCD_DISPCTRL_BIAS_MASK
 |

78 
_LCD_DISPCTRL_WAVE_MASK
 |

79 
_LCD_DISPCTRL_VLCDSEL_MASK
 |

80 
_LCD_DISPCTRL_CONCONF_MASK
);

83 
diCl
 |
lcdIn
->
mux
;

84 
diCl
 |
lcdIn
->
bs
;

85 
diCl
 |
lcdIn
->
wave
;

86 
diCl
 |
lcdIn
->
vlcd
;

87 
diCl
 |
lcdIn
->
cڌa
;

90 
LCD
->
DISPCTRL
 = 
diCl
;

93 i(
lcdIn
->
ab
)

95 
	`LCD_Eb
(
ue
);

97 
	}
}

107 
	$LCD_VLCDSe
(
LCD_VLCDS_TyDef
 
vlcd
)

109 
ut32_t
 
di
 = 
LCD
->
DISPCTRL
;

112 
di
 &~(
_LCD_DISPCTRL_VLCDSEL_MASK
);

113 
vlcd
)

115 
lcdVLCDSVExtBoo
:

116 
di
 |
LCD_DISPCTRL_VLCDSEL_VEXTBOOST
;

118 
lcdVLCDSVDD
:

119 
di
 |
LCD_DISPCTRL_VLCDSEL_VDD
;

125 
LCD
->
DISPCTRL
 = 
di
;

126 
	}
}

136 
	$LCD_UpdeCl
(
LCD_UpdeCl_TyDef
 
ud
)

138 
LCD
->
CTRL
 = (LCD->CTRL & ~
_LCD_CTRL_UDCTRL_MASK
| 
ud
;

139 
	}
}

149 
	$LCD_FmeCouIn
(cڡ 
LCD_FmeCouIn_TyDef
 *
fcIn
)

151 
ut32_t
 
ba
 = 
LCD
->
BACTRL
;

153 
	`EFM_ASSERT
(
fcIn
 != (*) 0);

156 
	`EFM_ASSERT
(
fcIn
->
t
 < 64);

159 
ba
 &~(
_LCD_BACTRL_FCTOP_MASK
 |

160 
_LCD_BACTRL_FCPRESC_MASK
);

161 
ba
 |(
fcIn
->
t
 << 
_LCD_BACTRL_FCTOP_SHIFT
);

162 
ba
 |
fcIn
->
es
;

165 
LCD
->
BACTRL
 = 
ba
;

167 
	`LCD_FmeCouEb
(
fcIn
->
ab
);

168 
	}
}

178 
	$LCD_AnimIn
(cڡ 
LCD_AnimIn_TyDef
 *
imIn
)

180 
ut32_t
 
ba
 = 
LCD
->
BACTRL
;

182 
	`EFM_ASSERT
(
imIn
 != (*) 0);

185 
LCD
->
AREGA
 = 
imIn
->
AReg
;

186 
LCD
->
AREGB
 = 
imIn
->
BReg
;

189 
ba
 &~(
_LCD_BACTRL_AREGASC_MASK
 |

190 
_LCD_BACTRL_AREGBSC_MASK
 |

191 
_LCD_BACTRL_ALOGSEL_MASK
);

193 
ba
 |(
imIn
->
AShi
 << 
_LCD_BACTRL_AREGASC_SHIFT
);

194 
ba
 |(
imIn
->
BShi
 << 
_LCD_BACTRL_AREGBSC_SHIFT
);

195 
ba
 |
imIn
->
imLogic
;

197 #i
	`defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

198 
ba
 &~(
_LCD_BACTRL_ALOC_MASK
);

200 if(
imIn
->
tSeg
 == 0)

202 
ba
 |
LCD_BACTRL_ALOC_SEG0TO7
;

204 if(
imIn
->
tSeg
 == 8)

206 
ba
 |
LCD_BACTRL_ALOC_SEG8TO15
;

211 
LCD
->
BACTRL
 = 
ba
;

214 
	`LCD_AnimEb
(
imIn
->
ab
);

215 
	}
}

229 
	$LCD_SegmtRgeEb
(
LCD_SegmtRge_TyDef
 
gmtRge
, 
bo
 
ab
)

231 i(
ab
)

233 
LCD
->
SEGEN
 |
gmtRge
;

237 
LCD
->
SEGEN
 &~((
ut32_t
)
gmtRge
);

239 
	}
}

260 
	$LCD_SegmtS
(
com
, 
b
, 
bo
 
ab
)

262 #i
	`defed
(
_EFM32_TINY_FAMILY
|| defed(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

264 
	`EFM_ASSERT
(
com
 < 8);

267 
	`EFM_ASSERT
(
com
 < 4);

270 #i
	`defed
(
_EFM32_GECKO_FAMILY
|| defed(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

271 
	`EFM_ASSERT
(
b
 < 40);

274 
	`EFM_ASSERT
(
b
 < 32);

278 
com
)

281 i(
b
 < 32)

283 
	`BITBAND_Ph
(&(
LCD
->
SEGD0L
), 
b
, ()
ab
);

285 #i
	`defed
(
_EFM32_GECKO_FAMILY
|| defed(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

288 
b
 -= 32;

289 
	`BITBAND_Ph
(&(
LCD
->
SEGD0H
), 
b
, ()
ab
);

294 i(
b
 < 32)

296 
	`BITBAND_Ph
(&(
LCD
->
SEGD1L
), 
b
, ()
ab
);

298 #i
	`defed
(
_EFM32_GECKO_FAMILY
|| defed(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

301 
b
 -= 32;

302 
	`BITBAND_Ph
(&(
LCD
->
SEGD1H
), 
b
, ()
ab
);

307 i(
b
 < 32)

309 
	`BITBAND_Ph
(&(
LCD
->
SEGD2L
), 
b
, ()
ab
);

311 #i
	`defed
(
_EFM32_GECKO_FAMILY
|| defed(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

314 
b
 -= 32;

315 
	`BITBAND_Ph
(&(
LCD
->
SEGD2H
), 
b
, ()
ab
);

320 i(
b
 < 32)

322 
	`BITBAND_Ph
(&(
LCD
->
SEGD3L
), 
b
, ()
ab
);

324 #i
	`defed
(
_EFM32_GECKO_FAMILY
|| defed(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

327 
b
 -= 32;

328 
	`BITBAND_Ph
(&(
LCD
->
SEGD3H
), 
b
, ()
ab
);

333 #i
	`defed
(
_EFM32_TINY_FAMILY
|| defed(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

334 i(
b
 < 32)

336 
	`BITBAND_Ph
(&(
LCD
->
SEGD4L
), 
b
, ()
ab
);

339 #i
	`defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

342 
b
 -= 32;

343 
	`BITBAND_Ph
(&(
LCD
->
SEGD4H
), 
b
, ()
ab
);

348 #i
	`defed
(
_EFM32_TINY_FAMILY
|| defed(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

349 i(
b
 < 32)

351 
	`BITBAND_Ph
(&(
LCD
->
SEGD5L
), 
b
, ()
ab
);

354 #i
	`defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

357 
b
 -= 32;

358 
	`BITBAND_Ph
(&(
LCD
->
SEGD5H
), 
b
, ()
ab
);

363 #i
	`defed
(
_EFM32_TINY_FAMILY
|| defed(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

364 i(
b
 < 32)

366 
	`BITBAND_Ph
(&(
LCD
->
SEGD6L
), 
b
, ()
ab
);

369 #i
	`defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

372 
b
 -= 32;

373 
	`BITBAND_Ph
(&(
LCD
->
SEGD6H
), 
b
, ()
ab
);

378 #i
	`defed
(
_EFM32_TINY_FAMILY
|| defed(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

379 i(
b
 < 32)

381 
	`BITBAND_Ph
(&(
LCD
->
SEGD7L
), 
b
, ()
ab
);

384 #i
	`defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

387 
b
 -= 32;

388 
	`BITBAND_Ph
(&(
LCD
->
SEGD7H
), 
b
, ()
ab
);

394 
	`EFM_ASSERT
(0);

397 
	}
}

414 
	$LCD_SegmtSLow
(
com
, 
ut32_t
 
mask
, ut32_
bs
)

416 
ut32_t
 
gDa
;

419 #i
	`defed
(
_EFM32_TINY_FAMILY
|| defed(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

420 
	`EFM_ASSERT
(
com
 < 8);

423 
	`EFM_ASSERT
(
com
 < 4);

426 
com
)

429 
gDa
 = 
LCD
->
SEGD0L
;

430 
gDa
 &~(
mask
);

431 
gDa
 |(
mask
 & 
bs
);

432 
LCD
->
SEGD0L
 = 
gDa
;

435 
gDa
 = 
LCD
->
SEGD1L
;

436 
gDa
 &~(
mask
);

437 
gDa
 |(
mask
 & 
bs
);

438 
LCD
->
SEGD1L
 = 
gDa
;

441 
gDa
 = 
LCD
->
SEGD2L
;

442 
gDa
 &~(
mask
);

443 
gDa
 |(
mask
 & 
bs
);

444 
LCD
->
SEGD2L
 = 
gDa
;

447 
gDa
 = 
LCD
->
SEGD3L
;

448 
gDa
 &~(
mask
);

449 
gDa
 |(
mask
 & 
bs
);

450 
LCD
->
SEGD3L
 = 
gDa
;

452 #i
	`defed
(
_EFM32_TINY_FAMILY
|| defed(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

454 
gDa
 = 
LCD
->
SEGD4L
;

455 
gDa
 &~(
mask
);

456 
gDa
 |(
mask
 & 
bs
);

457 
LCD
->
SEGD4L
 = 
gDa
;

460 #i
	`defed
(
_EFM32_TINY_FAMILY
|| defed(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

462 
gDa
 = 
LCD
->
SEGD5L
;

463 
gDa
 &~(
mask
);

464 
gDa
 |(
mask
 & 
bs
);

465 
LCD
->
SEGD5L
 = 
gDa
;

468 #i
	`defed
(
_EFM32_TINY_FAMILY
|| defed(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

470 
gDa
 = 
LCD
->
SEGD6L
;

471 
gDa
 &~(
mask
);

472 
gDa
 |(
mask
 & 
bs
);

473 
LCD
->
SEGD6L
 = 
gDa
;

476 #i
	`defed
(
_EFM32_TINY_FAMILY
|| defed(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

478 
gDa
 = 
LCD
->
SEGD7L
;

479 
gDa
 &~(
mask
);

480 
gDa
 |(
mask
 & 
bs
);

481 
LCD
->
SEGD7L
 = 
gDa
;

485 
	`EFM_ASSERT
(0);

488 
	}
}

491 #i
defed
(
_EFM32_GECKO_FAMILY
|| defed(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

505 
	$LCD_SegmtSHigh
(
com
, 
ut32_t
 
mask
, ut32_
bs
)

507 
ut32_t
 
gDa
;

509 #i
	`defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

510 
	`EFM_ASSERT
(
com
 < 8);

512 #i
	`defed
(
_EFM32_GECKO_FAMILY
)

513 
	`EFM_ASSERT
(
com
 < 4);

517 
com
)

520 
gDa
 = 
LCD
->
SEGD0H
;

521 
gDa
 &~(
mask
);

522 
gDa
 |(
mask
 & 
bs
);

523 
LCD
->
SEGD0H
 = 
gDa
;

526 
gDa
 = 
LCD
->
SEGD1H
;

527 
gDa
 &~(
mask
);

528 
gDa
 |(
mask
 & 
bs
);

529 
LCD
->
SEGD1H
 = 
gDa
;

532 
gDa
 = 
LCD
->
SEGD2H
;

533 
gDa
 &~(
mask
);

534 
gDa
 |(
mask
 & 
bs
);

535 
LCD
->
SEGD2H
 = 
gDa
;

538 
gDa
 = 
LCD
->
SEGD3H
;

539 
gDa
 &~(
mask
);

540 
gDa
 |(
mask
 & 
bs
);

541 
LCD
->
SEGD3H
 = 
gDa
;

543 #i
	`defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

545 
gDa
 = 
LCD
->
SEGD4H
;

546 
gDa
 &~(
mask
);

547 
gDa
 |(
mask
 & 
bs
);

548 
LCD
->
SEGD4H
 = 
gDa
;

551 #i
	`defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

553 
gDa
 = 
LCD
->
SEGD5H
;

554 
gDa
 &~(
mask
);

555 
gDa
 |(
mask
 & 
bs
);

556 
LCD
->
SEGD5H
 = 
gDa
;

559 #i
	`defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

561 
gDa
 = 
LCD
->
SEGD6H
;

562 
gDa
 &~(
mask
);

563 
gDa
 |(
mask
 & 
bs
);

564 
LCD
->
SEGD6H
 = 
gDa
;

567 #i
	`defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

569 
gDa
 = 
LCD
->
SEGD7H
;

570 
gDa
 &~(
mask
);

571 
gDa
 |(
mask
 & 
bs
);

572 
LCD
->
SEGD7H
 = 
gDa
;

578 
	}
}

588 
	$LCD_CڌaS
(
v
)

590 
	`EFM_ASSERT
(
v
 < 32);

592 
LCD
->
DISPCTRL
 = (LCD->DISPCTRL & ~
_LCD_DISPCTRL_CONLEV_MASK
)

593 | (
v
 << 
_LCD_DISPCTRL_CONLEV_SHIFT
);

594 
	}
}

606 
	$LCD_VBooS
(
LCD_VBooLev_TyDef
 
vboo
)

609 
LCD
->
DISPCTRL
 = (LCD->DISPCTRL & ~
_LCD_DISPCTRL_VBLEV_MASK
| 
vboo
;

610 
	}
}

613 #i
defed
(
_EFM32_TINY_FAMILY
|| defed(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

633 
	$LCD_BsSegmtS
(
gmtLe
, 
bsLev
)

635 
bsRegi
;

636 
bShi
;

637 vީ
ut32_t
 *
gmtRegi
;

639 #i
	`defed
(
_EFM32_TINY_FAMILY
)

640 
	`EFM_ASSERT
(
gmtLe
 < 20);

642 #i
	`defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

643 
	`EFM_ASSERT
(
gmtLe
 < 40);

645 #i
	`defed
(
_EFM32_TINY_FAMILY
)

647 
bsRegi
 = 
gmtLe
 / 8;

648 
bShi
 = (
gmtLe
 % 8) * 4;

650 
bsRegi
)

653 
gmtRegi
 = &
LCD
->
SEGD0L
;

656 
gmtRegi
 = &
LCD
->
SEGD1L
;

659 
gmtRegi
 = &
LCD
->
SEGD2L
;

662 
gmtRegi
 = &
LCD
->
SEGD3L
;

665 
gmtRegi
 = (
ut32_t
 *)0x00000000;

666 
	`EFM_ASSERT
(0);

670 #i
	`defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

672 
bsRegi
 = 
gmtLe
 / 10;

673 
bShi
 = (
gmtLe
 % 10) * 4;

675 
bsRegi
)

678 i(
bShi
 < 32)

680 
gmtRegi
 = &
LCD
->
SEGD0L
;

684 
gmtRegi
 = &
LCD
->
SEGD0H
;

685 
bShi
 -= 32;

689 i(
bShi
 < 32)

691 
gmtRegi
 = &
LCD
->
SEGD1L
;

695 
gmtRegi
 = &
LCD
->
SEGD1H
;

696 
bShi
 -= 32;

700 i(
bShi
 < 32)

702 
gmtRegi
 = &
LCD
->
SEGD2L
;

706 
gmtRegi
 = &
LCD
->
SEGD1H
;

707 
bShi
 -= 32;

711 i(
bShi
 < 32)

713 
gmtRegi
 = &
LCD
->
SEGD3L
;

717 
gmtRegi
 = &
LCD
->
SEGD3H
;

718 
bShi
 -= 32;

722 
gmtRegi
 = (
ut32_t
 *)0x00000000;

723 
	`EFM_ASSERT
(0);

729 *
gmtRegi
 = (*gmtRegi & ~(0xF << 
bShi
)| (
bsLev
 << bitShift);

730 
	}
}

752 
	$LCD_BsComS
(
comLe
, 
bsLev
)

754 
bShi
;

755 
	`EFM_ASSERT
(
comLe
 < 8);

757 
bShi
 = 
comLe
 * 4;

758 
LCD
->
SEGD4L
 = (LCD->SEGD4L & ~(0xF << 
bShi
)| (
bsLev
 << bitShift);

759 
	}
}

	@C:\Users\Alexander\AppData\Roaming\energymicro\emlib\src\em_letimer.c

33 
	~"em_tim.h
"

34 
	~"em_cmu.h
"

35 
	~"em_as.h
"

55 
	#LETIMER_COMP_REG_VALID
(
g
((eg<1))

	)

58 
	#LETIMER_REF_VALID
(
f
(ef=
LETIMER0
)

	)

61 
	#LETIMER_REP_REG_VALID
(
g
((eg<1))

	)

72 #i
defed
(
_EFM32_GECKO_FAMILY
)

89 
__STATIC_INLINE
 
	$LETIMER_Sync
(
LETIMER_TyDef
 *
tim
, 
ut32_t
 
mask
)

93 i(
tim
->
FREEZE
 & 
LETIMER_FREEZE_REGFREEZE
)

98 
tim
->
SYNCBUSY
 & 
mask
)

100 
	}
}

122 
ut32_t
 
	$LETIMER_ComG
(
LETIMER_TyDef
 *
tim
, 
comp
)

124 
ut32_t
 
t
;

126 
	`EFM_ASSERT
(
	`LETIMER_REF_VALID
(
tim
&& 
	`LETIMER_COMP_REG_VALID
(
comp
));

129 
comp
)

132 
t
 = 
tim
->
COMP0
;

136 
t
 = 
tim
->
COMP1
;

141 
t
 = 0;

145 (
t
);

146 
	}
}

169 
	$LETIMER_ComS
(
LETIMER_TyDef
 *
tim
,

170 
comp
,

171 
ut32_t
 
vue
)

173 vީ
ut32_t
 *
compReg
;

175 
	`EFM_ASSERT
(
	`LETIMER_REF_VALID
(
tim
) &&

176 
	`LETIMER_COMP_REG_VALID
(
comp
) &&

177 ((
vue
 & ~(
_LETIMER_COMP0_COMP0_MASK
 >> 
_LETIMER_COMP0_COMP0_SHIFT
)) == 0));

180 
comp
)

183 
compReg
 = &(
tim
->
COMP0
);

187 
compReg
 = &(
tim
->
COMP1
);

195 #i
	`defed
(
_EFM32_GECKO_FAMILY
)

197 
	`LETIMER_Sync
(
tim
, 
comp
 ? 
LETIMER_SYNCBUSY_COMP1
 : 
LETIMER_SYNCBUSY_COMP0
);

200 *
compReg
 = 
vue
;

201 
	}
}

222 
	$LETIMER_Eb
(
LETIMER_TyDef
 *
tim
, 
bo
 
ab
)

224 
	`EFM_ASSERT
(
	`LETIMER_REF_VALID
(
tim
));

226 #i
	`defed
(
_EFM32_GECKO_FAMILY
)

228 
	`LETIMER_Sync
(
tim
, 
LETIMER_SYNCBUSY_CMD
);

231 i(
ab
)

233 
tim
->
CMD
 = 
LETIMER_CMD_START
;

237 
tim
->
CMD
 = 
LETIMER_CMD_STOP
;

239 
	}
}

269 
	$LETIMER_FezeEb
(
LETIMER_TyDef
 *
tim
, 
bo
 
ab
)

271 i(
ab
)

282 
tim
->
SYNCBUSY
)

285 
tim
->
FREEZE
 = 
LETIMER_FREEZE_REGFREEZE
;

289 
tim
->
FREEZE
 = 0;

291 
	}
}

318 
	$LETIMER_In
(
LETIMER_TyDef
 *
tim
, cڡ 
LETIMER_In_TyDef
 *

)

320 
ut32_t
 
tmp
 = 0;

322 
	`EFM_ASSERT
(
	`LETIMER_REF_VALID
(
tim
));

325 i(!(

->
ab
&& (
tim
->
STATUS
 & 
LETIMER_STATUS_RUNNING
))

327 #i
	`defed
(
_EFM32_GECKO_FAMILY
)

329 
	`LETIMER_Sync
(
tim
, 
LETIMER_SYNCBUSY_CMD
);

331 
tim
->
CMD
 = 
LETIMER_CMD_STOP
;

336 i(

->
debugRun
)

338 
tmp
 |
LETIMER_CTRL_DEBUGRUN
;

341 i(

->
cComp0Eb
)

343 
tmp
 |
LETIMER_CTRL_RTCC0TEN
;

346 i(

->
cComp1Eb
)

348 
tmp
 |
LETIMER_CTRL_RTCC1TEN
;

351 i(

->
comp0T
)

353 
tmp
 |
LETIMER_CTRL_COMP0TOP
;

356 i(

->
bufT
)

358 
tmp
 |
LETIMER_CTRL_BUFTOP
;

361 i(

->
out0P
)

363 
tmp
 |
LETIMER_CTRL_OPOL0
;

366 i(

->
out1P
)

368 
tmp
 |
LETIMER_CTRL_OPOL1
;

371 
tmp
 |

->
uf0
 << 
_LETIMER_CTRL_UFOA0_SHIFT
;

372 
tmp
 |

->
uf1
 << 
_LETIMER_CTRL_UFOA1_SHIFT
;

373 
tmp
 |

->
pMode
 << 
_LETIMER_CTRL_REPMODE_SHIFT
;

375 #i
	`defed
(
_EFM32_GECKO_FAMILY
)

377 
	`LETIMER_Sync
(
tim
, 
LETIMER_SYNCBUSY_CTRL
);

379 
tim
->
CTRL
 = 
tmp
;

382 i(

->
ab
 && !(
tim
->
STATUS
 & 
LETIMER_STATUS_RUNNING
))

384 #i
	`defed
(
_EFM32_GECKO_FAMILY
)

386 
	`LETIMER_Sync
(
tim
, 
LETIMER_SYNCBUSY_CMD
);

388 
tim
->
CMD
 = 
LETIMER_CMD_START
;

390 
	}
}

406 
ut32_t
 
	$LETIMER_RtG
(
LETIMER_TyDef
 *
tim
, 
p
)

408 
ut32_t
 
t
;

410 
	`EFM_ASSERT
(
	`LETIMER_REF_VALID
(
tim
&& 
	`LETIMER_REP_REG_VALID
(
p
));

413 
p
)

416 
t
 = 
tim
->
REP0
;

420 
t
 = 
tim
->
REP1
;

425 
t
 = 0;

429 (
t
);

430 
	}
}

453 
	$LETIMER_RtS
(
LETIMER_TyDef
 *
tim
,

454 
p
,

455 
ut32_t
 
vue
)

457 vީ
ut32_t
 *
pReg
;

458 #i
	`defed
(
_EFM32_GECKO_FAMILY
)

459 
ut32_t
 
syncbusy
;

461 
	`EFM_ASSERT
(
	`LETIMER_REF_VALID
(
tim
) &&

462 
	`LETIMER_REP_REG_VALID
(
p
) &&

463 ((
vue
 & ~(
_LETIMER_REP0_REP0_MASK
 >> 
_LETIMER_REP0_REP0_SHIFT
)) == 0));

466 
p
)

469 
pReg
 = &(
tim
->
REP0
);

470 #i
	`defed
(
_EFM32_GECKO_FAMILY
)

471 
syncbusy
 = 
LETIMER_SYNCBUSY_REP0
;

476 
pReg
 = &(
tim
->
REP1
);

477 #i
	`defed
(
_EFM32_GECKO_FAMILY
)

478 
syncbusy
 = 
LETIMER_SYNCBUSY_REP1
;

487 #i
	`defed
(
_EFM32_GECKO_FAMILY
)

489 
	`LETIMER_Sync
(
tim
, 
syncbusy
);

492 *
pReg
 = 
vue
;

493 
	}
}

507 
	$LETIMER_Ret
(
LETIMER_TyDef
 *
tim
)

510 
	`LETIMER_FezeEb
(
tim
, 
ue
);

513 
tim
->
CMD
 = 
LETIMER_CMD_STOP
 | 
LETIMER_CMD_CLEAR
 |

514 
LETIMER_CMD_CTO0
 | 
LETIMER_CMD_CTO1
;

515 
tim
->
CTRL
 = 
_LETIMER_CTRL_RESETVALUE
;

516 
tim
->
COMP0
 = 
_LETIMER_COMP0_RESETVALUE
;

517 
tim
->
COMP1
 = 
_LETIMER_COMP1_RESETVALUE
;

518 
tim
->
REP0
 = 
_LETIMER_REP0_RESETVALUE
;

519 
tim
->
REP1
 = 
_LETIMER_REP1_RESETVALUE
;

520 
tim
->
IEN
 = 
_LETIMER_IEN_RESETVALUE
;

521 
tim
->
IFC
 = 
_LETIMER_IFC_MASK
;

525 
	`LETIMER_FezeEb
(
tim
, 
l
);

526 
	}
}

	@C:\Users\Alexander\AppData\Roaming\energymicro\emlib\src\em_pcnt.c

33 
	~"em_pt.h
"

34 
	~"em_cmu.h
"

35 
	~"em_as.h
"

36 
	~"em_bbd.h
"

57 #i(
PCNT_COUNT
 == 1)

58 
	#PCNT_REF_VALID
(
f
(ef=
PCNT0
)

	)

59 #i(
PCNT_COUNT
 == 2)

60 
	#PCNT_REF_VALID
(
f
((ef=
PCNT0
|| (ef=
PCNT1
))

	)

61 #i(
PCNT_COUNT
 == 3)

62 
	#PCNT_REF_VALID
(
f
((ef=
PCNT0
|| (ef=
PCNT1
) || \

63 ((
f
=
PCNT2
))

	)

65 #r 
Undefed
 
numb
 
of
 
pul
 
cous
 (
PCNT
).

87 
__STATIC_INLINE
 
	$PCNT_M
(
PCNT_TyDef
 *
pt
)

89 (((
ut32_t
)
pt
 - 
PCNT0_BASE
) / 0x400);

90 
	}
}

104 
__STATIC_INLINE
 
	$PCNT_Sync
(
PCNT_TyDef
 *
pt
, 
ut32_t
 
mask
)

108 i(
pt
->
FREEZE
 & 
PCNT_FREEZE_REGFREEZE
)

115 
pt
->
SYNCBUSY
 & 
mask
)

117 
	}
}

139 
	$PCNT_CouRet
(
PCNT_TyDef
 *
pt
)

141 
	`EFM_ASSERT
(
	`PCNT_REF_VALID
(
pt
));

144 
	`BITBAND_Ph
(&(
pt
->
CTRL
), 
_PCNT_CTRL_RSTEN_SHIFT
, 1);

147 
	`BITBAND_Ph
(&(
pt
->
CTRL
), 
_PCNT_CTRL_RSTEN_SHIFT
, 0);

148 
	}
}

175 
	$PCNT_CouTS
(
PCNT_TyDef
 *
pt
, 
ut32_t
 
cou
, ut32_
t
)

177 
ut32_t
 

;

179 
	`EFM_ASSERT
(
	`PCNT_REF_VALID
(
pt
));

182 

 = 
pt
->
CTRL
;

185 i((

 & 
_PCNT_CTRL_MODE_MASK
!
PCNT_CTRL_MODE_DISABLE
)

187 
	`PCNT_Sync
(
pt
, 
PCNT_SYNCBUSY_CTRL
);

188 
pt
->
CTRL
 = (

 & ~
_PCNT_CTRL_MODE_MASK
| 
PCNT_CTRL_MODE_DISABLE
;

192 
	`PCNT_Sync
(
pt
, 
PCNT_SYNCBUSY_TOPB
);

193 
pt
->
TOPB
 = 
cou
;

196 
	`PCNT_Sync
(
pt
, 
PCNT_SYNCBUSY_TOPB
 | 
PCNT_SYNCBUSY_CMD
);

199 
pt
->
CMD
 = 
PCNT_CMD_LTOPBIM
;

200 
	`PCNT_Sync
(
pt
, 
PCNT_SYNCBUSY_CMD
);

203 
pt
->
CMD
 = 
PCNT_CMD_LCNTIM
;

208 i(
t
 !
cou
)

211 
	`PCNT_Sync
(
pt
, 
PCNT_SYNCBUSY_CMD
);

215 
pt
->
TOPB
 = 
t
;

218 
	`PCNT_Sync
(
pt
, 
PCNT_SYNCBUSY_TOPB
 | 
PCNT_SYNCBUSY_CMD
);

219 
pt
->
CMD
 = 
PCNT_CMD_LTOPBIM
;

223 i((

 & 
_PCNT_CTRL_MODE_MASK
!
PCNT_CTRL_MODE_DISABLE
)

225 
	`PCNT_Sync
(
pt
, 
PCNT_SYNCBUSY_CTRL
 | 
PCNT_SYNCBUSY_CMD
);

226 
pt
->
CTRL
 = 

;

228 
	}
}

253 
	$PCNT_Eb
(
PCNT_TyDef
 *
pt
, 
PCNT_Mode_TyDef
 
mode
)

255 
ut32_t
 
tmp
;

257 
	`EFM_ASSERT
(
	`PCNT_REF_VALID
(
pt
));

260 
tmp
 = 
pt
->
CTRL
 & ~
_PCNT_CTRL_MODE_MASK
;

261 
tmp
 |(
ut32_t
)
mode
 << 
_PCNT_CTRL_MODE_SHIFT
;

264 
	`PCNT_Sync
(
pt
, 
PCNT_SYNCBUSY_CTRL
);

265 
pt
->
CTRL
 = 
tmp
;

266 
	}
}

268 #i(
defed
 (
_EFM32_TINY_FAMILY
|| defed (
_EFM32_GIANT_FAMILY
|| defed (
_EFM32_WONDER_FAMILY
))

285 
	$PCNT_PRSIutEb
(
PCNT_TyDef
 *
pt
,

286 
PCNT_PRSIut_TyDef
 
sIut
,

287 
bo
 
ab
)

289 
	`EFM_ASSERT
(
	`PCNT_REF_VALID
(
pt
));

292 
sIut
)

295 
ptPRSIutS0
:

297 
	`BITBAND_Ph
(&(
pt
->
INPUT
), 
_PCNT_INPUT_S0PRSEN_SHIFT
, (
ut32_t
)
ab
);

302 
ptPRSIutS1
:

304 
	`BITBAND_Ph
(&(
pt
->
INPUT
), 
_PCNT_INPUT_S1PRSEN_SHIFT
, (
ut32_t
)
ab
);

311 
	`EFM_ASSERT
(0);

315 
	}
}

346 
	$PCNT_FezeEb
(
PCNT_TyDef
 *
pt
, 
bo
 
ab
)

348 
	`EFM_ASSERT
(
	`PCNT_REF_VALID
(
pt
));

350 i(
ab
)

359 
pt
->
SYNCBUSY
)

362 
pt
->
FREEZE
 = 
PCNT_FREEZE_REGFREEZE
;

366 
pt
->
FREEZE
 = 0;

368 
	}
}

410 
	$PCNT_In
(
PCNT_TyDef
 *
pt
, cڡ 
PCNT_In_TyDef
 *

)

412 

;

413 
ut32_t
 
tmp
;

415 
	`EFM_ASSERT
(
	`PCNT_REF_VALID
(
pt
));

418 

 = 
	`PCNT_M
(
pt
);

420 #i(
	`defed
 (
_EFM32_TINY_FAMILY
|| defed (
_EFM32_GIANT_FAMILY
|| defed (
_EFM32_WONDER_FAMILY
))

424 
tmp
 = 
pt
->
INPUT
 & ~(
_PCNT_INPUT_S0PRSSEL_MASK
 | 
_PCNT_INPUT_S1PRSSEL_MASK
);

425 
tmp
 |((
ut32_t
)

->
s0PRS
 << 
_PCNT_INPUT_S0PRSSEL_SHIFT
) |

426 ((
ut32_t
)

->
s1PRS
 << 
_PCNT_INPUT_S1PRSSEL_SHIFT
);

427 
pt
->
INPUT
 = 
tmp
;

431 
tmp
 = 0;

432 i(

->
gEdge
)

434 
tmp
 |
PCNT_CTRL_EDGE_NEG
;

437 i(

->
couDown
)

439 
tmp
 |
PCNT_CTRL_CNTDIR_DOWN
;

442 i(

->
fr
)

444 
tmp
 |
PCNT_CTRL_FILT
;

447 #i(
	`defed
 (
_EFM32_TINY_FAMILY
|| defed (
_EFM32_GIANT_FAMILY
|| defed (
_EFM32_WONDER_FAMILY
))

448 i(

->
hy
)

450 
tmp
 |
PCNT_CTRL_HYST
;

453 i(

->
s1CD
)

455 
tmp
 |
PCNT_CTRL_S1CDIR
;

459 
tmp
 |

->
tEvt
 << 
_PCNT_CTRL_CNTEV_SHIFT
;

460 
tmp
 |

->
auxCEvt
 << 
_PCNT_CTRL_AUXCNTEV_SHIFT
;

465 
	`BITBAND_Ph
(&(
pt
->
CTRL
), 
_PCNT_CTRL_RSTEN_SHIFT
, 1);

468 
	`CMU_PCNTClockExS
(

, 
l
);

471 

->
mode
)

473 
ptModeExtSg
:

474 
ptModeExtQuad
:

475 
tmp
 |

->
mode
 << 
_PCNT_CTRL_MODE_SHIFT
;

481 
	`PCNT_Sync
(
pt
, 
PCNT_SYNCBUSY_CTRL
);

485 
pt
->
CTRL
 = 
PCNT_CTRL_RSTEN
;

488 
	`PCNT_Sync
(
pt
, 
PCNT_SYNCBUSY_CTRL
);

491 
	`CMU_PCNTClockExS
(

, 
ue
);

497 
pt
->
TOPB
 = 

->
t
;

500 
pt
->
CMD
 = 
PCNT_CMD_LTOPBIM
;

506 
pt
->
CTRL
 = 
tmp
;

518 i((
pt
->
CTRL
 & 
_PCNT_CTRL_MODE_MASK
!
PCNT_CTRL_MODE_DISABLE
)

523 
pt
->
CTRL
 = 
tmp
 | 
PCNT_CTRL_MODE_DISABLE
 | 
PCNT_CTRL_RSTEN
;

527 
	`PCNT_Sync
(
pt
, 
PCNT_SYNCBUSY_CTRL
);

531 
	`BITBAND_Ph
(&(
pt
->
CTRL
), 
_PCNT_CTRL_RSTEN_SHIFT
, 0);

534 
	`PCNT_CouTS
(
pt
, 

->
cou
, in->
t
);

537 i(

->
mode
 =
ptModeOvsSg
)

539 
	`PCNT_Sync
(
pt
, 
PCNT_SYNCBUSY_CTRL
);

540 
pt
->
CTRL
 = 
tmp
 | (

->
mode
 << 
_PCNT_CTRL_MODE_SHIFT
);

544 
	}
}

563 
	$PCNT_Ret
(
PCNT_TyDef
 *
pt
)

565 

;

567 
	`EFM_ASSERT
(
	`PCNT_REF_VALID
(
pt
));

570 

 = 
	`PCNT_M
(
pt
);

572 
pt
->
IEN
 = 
_PCNT_IEN_RESETVALUE
;

579 
	`BITBAND_Ph
(&(
pt
->
CTRL
), 
_PCNT_CTRL_RSTEN_SHIFT
, 1);

582 
	`CMU_PCNTClockExS
(

, 
l
);

584 
	`PCNT_TBufrS
(
pt
, 
_PCNT_TOPB_RESETVALUE
);

587 
pt
->
CTRL
 = 
_PCNT_CTRL_RESETVALUE
 | 
PCNT_CTRL_RSTEN
;

590 
	`PCNT_Sync
(
pt
, 
PCNT_SYNCBUSY_CTRL
);

591 
	`BITBAND_Ph
(&(
pt
->
CTRL
), 
_PCNT_CTRL_RSTEN_SHIFT
, 0);

594 
pt
->
IFC
 = 
_PCNT_IFC_MASK
;

597 
	}
}

616 
	$PCNT_TBufrS
(
PCNT_TyDef
 *
pt
, 
ut32_t
 
v
)

618 
	`EFM_ASSERT
(
	`PCNT_REF_VALID
(
pt
));

621 
	`PCNT_Sync
(
pt
, 
PCNT_SYNCBUSY_TOPB
);

622 
pt
->
TOPB
 = 
v
;

623 
	}
}

642 
	$PCNT_TS
(
PCNT_TyDef
 *
pt
, 
ut32_t
 
v
)

644 
	`EFM_ASSERT
(
	`PCNT_REF_VALID
(
pt
));

649 
	`PCNT_Sync
(
pt
, 
PCNT_SYNCBUSY_TOPB
);

650 
pt
->
TOPB
 = 
v
;

653 
	`PCNT_Sync
(
pt
, 
PCNT_SYNCBUSY_TOPB
 | 
PCNT_SYNCBUSY_CMD
);

654 
pt
->
CMD
 = 
PCNT_CMD_LTOPBIM
;

655 
	}
}

	@C:\Users\Alexander\AppData\Roaming\energymicro\emlib\src\em_rtc.c

33 
	~"em_c.h
"

34 
	~"em_as.h
"

35 
	~"em_bbd.h
"

55 
	#RTC_COMP_REG_VALID
(
g
((eg<1))

	)

66 #i
defed
(
_EFM32_GECKO_FAMILY
)

82 
__STATIC_INLINE
 
	$RTC_Sync
(
ut32_t
 
mask
)

86 i(
RTC
->
FREEZE
 & 
RTC_FREEZE_REGFREEZE
)

91 
RTC
->
SYNCBUSY
 & 
mask
)

93 
	}
}

112 
ut32_t
 
	$RTC_ComG
(
comp
)

114 
ut32_t
 
t
;

116 
	`EFM_ASSERT
(
	`RTC_COMP_REG_VALID
(
comp
));

119 
comp
)

122 
t
 = 
RTC
->
COMP0
;

126 
t
 = 
RTC
->
COMP1
;

131 
t
 = 0;

135  
t
;

136 
	}
}

156 
	$RTC_ComS
(
comp
, 
ut32_t
 
vue
)

158 vީ
ut32_t
 *
compReg
;

159 #i
	`defed
(
_EFM32_GECKO_FAMILY
)

160 
ut32_t
 
syncbusy
;

163 
	`EFM_ASSERT
(
	`RTC_COMP_REG_VALID
(
comp
) &&

164 ((
vue
 & ~(
_RTC_COMP0_COMP0_MASK
 >> 
_RTC_COMP0_COMP0_SHIFT
)) == 0));

167 
comp
)

170 
compReg
 = &(
RTC
->
COMP0
);

171 #i
	`defed
(
_EFM32_GECKO_FAMILY
)

172 
syncbusy
 = 
RTC_SYNCBUSY_COMP0
;

177 
compReg
 = &(
RTC
->
COMP1
);

178 #i
	`defed
(
_EFM32_GECKO_FAMILY
)

179 
syncbusy
 = 
RTC_SYNCBUSY_COMP1
;

187 #i
	`defed
(
_EFM32_GECKO_FAMILY
)

189 
	`RTC_Sync
(
syncbusy
);

192 *
compReg
 = 
vue
;

193 
	}
}

211 
	$RTC_Eb
(
bo
 
ab
)

213 #i
	`defed
(
_EFM32_GECKO_FAMILY
)

215 
	`RTC_Sync
(
RTC_SYNCBUSY_CTRL
);

218 
	`BITBAND_Ph
(&(
RTC
->
CTRL
), 
_RTC_CTRL_EN_SHIFT
, (
ab
);

219 
	}
}

248 
	$RTC_FezeEb
(
bo
 
ab
)

250 i(
ab
)

252 #i
	`defed
(
_EFM32_GECKO_FAMILY
)

260 
RTC
->
SYNCBUSY
)

263 
RTC
->
FREEZE
 = 
RTC_FREEZE_REGFREEZE
;

267 
RTC
->
FREEZE
 = 0;

269 
	}
}

292 
	$RTC_In
(cڡ 
RTC_In_TyDef
 *

)

294 
ut32_t
 
tmp
;

296 i(

->
ab
)

298 
tmp
 = 
RTC_CTRL_EN
;

302 
tmp
 = 0;

307 i(

->
debugRun
)

309 
tmp
 |
RTC_CTRL_DEBUGRUN
;

314 i(

->
comp0T
)

316 
tmp
 |
RTC_CTRL_COMP0TOP
;

319 #i
	`defed
(
_EFM32_GECKO_FAMILY
)

321 
	`RTC_Sync
(
RTC_SYNCBUSY_CTRL
);

324 
RTC
->
CTRL
 = 
tmp
;

325 
	}
}

333 
	$RTC_Ret
()

336 
RTC
->
FREEZE
 = 
_RTC_FREEZE_RESETVALUE
;

337 
RTC
->
CTRL
 = 
_RTC_CTRL_RESETVALUE
;

338 
RTC
->
COMP0
 = 
_RTC_COMP0_RESETVALUE
;

339 
RTC
->
COMP1
 = 
_RTC_COMP1_RESETVALUE
;

340 
RTC
->
IEN
 = 
_RTC_IEN_RESETVALUE
;

341 
RTC
->
IFC
 = 
_RTC_IFC_RESETVALUE
;

342 
	}
}

350 
	$RTC_CouRet
()

353 
	`RTC_Eb
(
l
);

354 
	`RTC_Eb
(
ue
);

355 
	}
}

	@C:\Users\Alexander\AppData\Roaming\energymicro\emlib\src\em_system.c

33 
	~"em_devi.h
"

34 
	~"em_syem.h
"

35 
	~"em_as.h
"

59 
	$SYSTEM_ChRevisiG
(
SYSTEM_ChRevisi_TyDef
 *
v
)

61 
ut8_t
 
tmp
;

63 
	`EFM_ASSERT
(
v
);

65 
v
->
maj
 = (
ROMTABLE
->
PID0
 & 
_ROMTABLE_PID0_REVMAJOR_MASK
>> 
_ROMTABLE_PID0_REVMAJOR_SHIFT
;

67 
tmp
 = (
ROMTABLE
->
PID2
 & 
_ROMTABLE_PID2_REVMINORMSB_MASK
);

68 
tmp
 |((
ROMTABLE
->
PID3
 & 
_ROMTABLE_PID3_REVMINORLSB_MASK
>> 
_ROMTABLE_PID3_REVMINORLSB_SHIFT
);

69 
v
->
m
 = 
tmp
;

70 
	}
}

82 
ut32_t
 
	$SYSTEM_GCibtiVue
(vީ
ut32_t
 *
gAddss
)

84 
gCou
;

85 
CALIBRATE_TyDef
 *
p
;

87 
gCou
 = 1;

88 
p
 = 
CALIBRATE
;

92 i((
gCou
 > 
CALIBRATE_MAX_REGISTERS
) ||

93 (
p
->
VALUE
 == 0xFFFFFFFF))

95 
	`EFM_ASSERT
(
l
);

99 i(
p
->
ADDRESS
 =(
ut32_t
)
gAddss
)

101  
p
->
VALUE
;

104 
p
++;

105 
gCou
++;

107 
	}
}

	@C:\Users\Alexander\AppData\Roaming\energymicro\emlib\src\em_usart.c

34 
	~"em_u.h
"

35 
	~"em_cmu.h
"

36 
	~"em_as.h
"

58 #i(
USART_COUNT
 == 1)

59 
	#USART_REF_VALID
(
f
(ef=
USART0
)

	)

61 #i(
USART_COUNT
 == 2)

62 
	#USART_REF_VALID
(
f
((ef=
USART0
|| (ef=
USART1
))

	)

64 #i(
USART_COUNT
 == 3)

65 
	#USART_REF_VALID
(
f
((ef=
USART0
|| (ef=
USART1
) || \

66 ((
f
=
USART2
))

	)

67 #i(
USART_COUNT
 == 4)

68 
	#USART_REF_VALID
(
f
((ef=
USART0
|| (ef=
USART1
) || \

69 ((
f
=
USART2
|| (ef=
USART3
))

	)

71 #r 
Undefed
 
numb
 
of
 
USARTs
.

74 #i
defed
(
USART0
)

75 
	#USART_IRDA_VALID
(
f
(ef=
USART0
)

	)

78 #i
defed
(
_EFM32_TINY_FAMILY
)

79 
	#USART_I2S_VALID
(
f
(ef=
USART1
)

	)

82 #i
defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

83 
	#USART_I2S_VALID
(
f
((ef=
USART1
|| (ef=
USART2
))

	)

86 #i(
UART_COUNT
 == 1)

87 
	#UART_REF_VALID
(
f
(ef)==
UART0
)

	)

88 #i(
UART_COUNT
 == 2)

89 
	#UART_REF_VALID
(
f
((ef)==
UART0
|| (ef)==
UART1
))

	)

91 
	#UART_REF_VALID
(
f
(0)

	)

123 
	$USART_BaudAsyncS
(
USART_TyDef
 *
u
,

124 
ut32_t
 
fFq
,

125 
ut32_t
 
baud
,

126 
USART_OVS_TyDef
 
ovs
)

128 
ut32_t
 
kdiv
;

129 
ut32_t
 
ovme
;

132 
	`EFM_ASSERT
(
baud
);

161 i(!
fFq
)

163 
fFq
 = 
	`CMU_ClockFqG
(
cmuClock_HFPER
);

167 
ovs
)

169 
USART_CTRL_OVS_X16
:

170 
	`EFM_ASSERT
(
baud
 <(
fFq
 / 16));

171 
ovme
 = 16;

174 
USART_CTRL_OVS_X8
:

175 
	`EFM_ASSERT
(
baud
 <(
fFq
 / 8));

176 
ovme
 = 8;

179 
USART_CTRL_OVS_X6
:

180 
	`EFM_ASSERT
(
baud
 <(
fFq
 / 6));

181 
ovme
 = 6;

184 
USART_CTRL_OVS_X4
:

185 
	`EFM_ASSERT
(
baud
 <(
fFq
 / 4));

186 
ovme
 = 4;

191 
	`EFM_ASSERT
(0);

196 
kdiv
 = 4 * 
fFq
 + (
ovme
 * 
baud
) / 2;

197 
kdiv
 /(
ovme
 * 
baud
);

198 
kdiv
 -= 4;

199 
kdiv
 *= 64;

202 
	`EFM_ASSERT
(
kdiv
 <
_USART_CLKDIV_MASK
);

205 
kdiv
 &
_USART_CLKDIV_MASK
;

207 
u
->
CTRL
 &~
_USART_CTRL_OVS_MASK
;

208 
u
->
CTRL
 |
ovs
;

209 
u
->
CLKDIV
 = 
kdiv
;

210 
	}
}

241 
ut32_t
 
	$USART_BaudCc
(
ut32_t
 
fFq
,

242 
ut32_t
 
kdiv
,

243 
bo
 
syncmode
,

244 
USART_OVS_TyDef
 
ovs
)

246 
ut32_t
 
ovme
;

247 
ut32_t
 
divis
;

248 
ut32_t
 

;

249 
ut32_t
 
mad
;

250 
ut32_t
 
quٛ
;

251 
ut32_t
 
br
;

254 
kdiv
 &
_USART_CLKDIV_MASK
;

260 i(
syncmode
)

271 
ovme
 = 1;

272 

 = 128;

289 
ovs
)

291 
USART_CTRL_OVS_X16
:

292 
ovme
 = 1;

293 

 = 256 / 16;

296 
USART_CTRL_OVS_X8
:

297 
ovme
 = 1;

298 

 = 256 / 8;

301 
USART_CTRL_OVS_X6
:

302 
ovme
 = 3;

303 

 = 256 / 2;

307 
ovme
 = 1;

308 

 = 256 / 4;

336 
divis
 = 
ovme
 * (256 + 
kdiv
);

338 
quٛ
 = 
fFq
 / 
divis
;

339 
mad
 = 
fFq
 % 
divis
;

343 
br
 = 

 * 
quٛ
;

350 
br
 +(

 * 
mad
/ 
divis
;

352  
br
;

353 
	}
}

370 
ut32_t
 
	$USART_BaudG
(
USART_TyDef
 *
u
)

372 
ut32_t
 
eq
;

373 
USART_OVS_TyDef
 
ovs
;

374 
bo
 
syncmode
;

376 i(
u
->
CTRL
 & 
USART_CTRL_SYNC
)

378 
syncmode
 = 
ue
;

382 
syncmode
 = 
l
;

386 
eq
 = 
	`CMU_ClockFqG
(
cmuClock_HFPER
);

387 
ovs
 = (
USART_OVS_TyDef
)(
u
->
CTRL
 & 
_USART_CTRL_OVS_MASK
);

388  
	`USART_BaudCc
(
eq
, 
u
->
CLKDIV
, 
syncmode
, 
ovs
);

389 
	}
}

419 
	$USART_BaudSyncS
(
USART_TyDef
 *
u
, 
ut32_t
 
fFq
, ut32_
baud
)

421 
ut32_t
 
kdiv
;

424 
	`EFM_ASSERT
(
baud
);

453 i(!
fFq
)

455 
fFq
 = 
	`CMU_ClockFqG
(
cmuClock_HFPER
);

459 
kdiv
 = 2 * 
fFq
;

460 
kdiv
 +
baud
 - 1;

461 
kdiv
 /
baud
;

462 
kdiv
 -= 4;

463 
kdiv
 *= 64;

467 
kdiv
 += 0xc0;

468 
kdiv
 &= 0xffffff00;

471 
	`EFM_ASSERT
(
kdiv
 <
_USART_CLKDIV_MASK
);

474 
kdiv
 &
_USART_CLKDIV_DIV_MASK
;

476 
u
->
CLKDIV
 = 
kdiv
;

477 
	}
}

495 
	$USART_Eb
(
USART_TyDef
 *
u
, 
USART_Eb_TyDef
 
ab
)

497 
ut32_t
 
tmp
;

500 
	`EFM_ASSERT
(
	`USART_REF_VALID
(
u
)||(
	`UART_REF_VALID
(usart)));

503 
tmp
 = ~((
ut32_t
)(
ab
));

504 
tmp
 &
_USART_CMD_RXEN_MASK
 | 
_USART_CMD_TXEN_MASK
;

505 
u
->
CMD
 = 
tmp
 << 1;

508 
u
->
CMD
 = (
ut32_t
)(
ab
);

509 
	}
}

535 
	$USART_InAsync
(
USART_TyDef
 *
u
, cڡ 
USART_InAsync_TyDef
 *

)

538 
	`EFM_ASSERT
(
	`USART_REF_VALID
(
u
)||
	`UART_REF_VALID
(usart));

541 
	`USART_Ret
(
u
);

543 #i
	`defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_TINY_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

545 i(

->
mvdis
)

547 
u
->
CTRL
 |
USART_CTRL_MVDIS
;

551 i(

->
sRxEb
)

553 
u
->
INPUT
 = (
ut32_t
)

->
sRxCh
 | 
USART_INPUT_RXPRS
;

558 
u
->
FRAME
 = (
ut32_t
)(

->
dabs
) |

559 (
ut32_t
)(

->
bs
) |

560 (
ut32_t
)(

->
ry
);

563 
	`USART_BaudAsyncS
(
u
, 

->
fFq
, in->
baud
, in->
ovmg
);

566 
u
->
CMD
 = (
ut32_t
)(

->
ab
);

567 
	}
}

594 
	$USART_InSync
(
USART_TyDef
 *
u
, cڡ 
USART_InSync_TyDef
 *

)

597 
	`EFM_ASSERT
(
	`USART_REF_VALID
(
u
));

600 
	`USART_Ret
(
u
);

603 
u
->
CTRL
 |(
USART_CTRL_SYNC
) |

604 ((
ut32_t
)

->
ockMode
) |

605 (

->
msbf
 ? 
USART_CTRL_MSBF
 : 0);

607 #i
	`defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_TINY_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

608 
u
->
CTRL
 |(

->
sRxEb
 ? 
USART_INPUT_RXPRS
 : 0) |

609 (

->
autoTx
 ? 
USART_CTRL_AUTOTX
 : 0);

613 
u
->
FRAME
 = ((
ut32_t
)(

->
dabs
)) |

614 (
USART_FRAME_STOPBITS_DEFAULT
) |

615 (
USART_FRAME_PARITY_DEFAULT
);

618 
	`USART_BaudSyncS
(
u
, 

->
fFq
, in->
baud
);

621 i(

->
ma
)

623 
u
->
CMD
 = 
USART_CMD_MASTEREN
;

626 
u
->
CMD
 = (
ut32_t
)(

->
ab
);

627 
	}
}

656 #i
defed
(
USART0
)

657 
	$USART_InIrDA
(cڡ 
USART_InIrDA_TyDef
 *

)

660 
	`USART_InAsync
(
USART0
, &(

->
async
));

663 
USART0
->
CTRL
 |
USART_CTRL_TXINV
;

666 i(

->
RxInv
)

668 
USART0
->
CTRL
 |
USART_CTRL_RXINV
;

672 
USART0
->
IRCTRL
 |(
ut32_t
)

->
Pw
 |

673 (
ut32_t
)

->
PrsS
 |

674 ((
ut32_t
)

->
Ft
 << 
_USART_IRCTRL_IRFILT_SHIFT
) |

675 ((
ut32_t
)

->
PrsEn
 << 
_USART_IRCTRL_IRPRSEN_SHIFT
);

678 
USART0
->
IRCTRL
 |
USART_IRCTRL_IREN
;

679 
	}
}

683 #i
defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_TINY_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

713 
	$USART_InI2s
(
USART_TyDef
 *
u
, 
USART_InI2s_TyDef
 *

)

715 
USART_Eb_TyDef
 
ab
;

718 
	`EFM_ASSERT
(
	`USART_I2S_VALID
(
u
));

721 
ab
 = 

->
sync
.enable;

722 

->
sync
.
ab
 = 
uDib
;

725 
	`USART_InSync
(
u
, &

->
sync
);

728 
u
->
I2SCTRL
 = ((
ut32_t
)

->
fm
) |

729 ((
ut32_t
)

->
juify
) |

730 (

->
day
 ? 
USART_I2SCTRL_DELAY
 : 0) |

731 (

->
dmaS
 ? 
USART_I2SCTRL_DMASPLIT
 : 0) |

732 (

->
mo
 ? 
USART_I2SCTRL_MONO
 : 0) |

733 (
USART_I2SCTRL_EN
);

735 i(
ab
 !
uDib
)

737 
	`USART_Eb
(
u
, 
ab
);

739 
	}
}

751 
	$USART_InPrsTrigg
(
USART_TyDef
 *
u
, cڡ 
USART_PrsTriggIn_TyDef
 *

)

753 
ut32_t
 
ig
;

756 
ig
 = 
u
->
TRIGCTRL
 & ~(
_USART_TRIGCTRL_RXTEN_MASK
|

757 
_USART_TRIGCTRL_TXTEN_MASK
|

758 #i
	`defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

759 
_USART_TRIGCTRL_AUTOTXTEN_MASK
|

761 
_USART_TRIGCTRL_TSEL_MASK
);

763 #i
	`defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

764 if(

->
autoTxTriggEb
)

766 
ig
 |
USART_TRIGCTRL_AUTOTXTEN
;

769 if(

->
txTriggEb
)

771 
ig
 |
USART_TRIGCTRL_TXTEN
;

773 if(

->
rxTriggEb
)

775 
ig
 |
USART_TRIGCTRL_RXTEN
;

777 
ig
 |

->
sTriggChl
;

780 
u
->
TRIGCTRL
 = 
ig
;

781 
	}
}

792 
	$USART_Ret
(
USART_TyDef
 *
u
)

795 
	`EFM_ASSERT
(
	`USART_REF_VALID
(
u
)||
	`UART_REF_VALID
(usart));

798 
u
->
CMD
 = 
USART_CMD_RXDIS
 | 
USART_CMD_TXDIS
 | 
USART_CMD_MASTERDIS
 |

799 
USART_CMD_RXBLOCKDIS
 | 
USART_CMD_TXTRIDIS
 | 
USART_CMD_CLEARTX
 | 
USART_CMD_CLEARRX
;

800 
u
->
CTRL
 = 
_USART_CTRL_RESETVALUE
;

801 
u
->
FRAME
 = 
_USART_FRAME_RESETVALUE
;

802 
u
->
TRIGCTRL
 = 
_USART_TRIGCTRL_RESETVALUE
;

803 
u
->
CLKDIV
 = 
_USART_CLKDIV_RESETVALUE
;

804 
u
->
IEN
 = 
_USART_IEN_RESETVALUE
;

805 
u
->
IFC
 = 
_USART_IFC_MASK
;

806 
u
->
ROUTE
 = 
_USART_ROUTE_RESETVALUE
;

808 i(
	`USART_IRDA_VALID
(
u
))

810 
u
->
IRCTRL
 = 
_USART_IRCTRL_RESETVALUE
;

813 #i
	`defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_TINY_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
)

814 
u
->
INPUT
 = 
_USART_INPUT_RESETVALUE
;

816 i(
	`USART_I2S_VALID
(
u
))

818 
u
->
I2SCTRL
 = 
_USART_I2SCTRL_RESETVALUE
;

821 
	}
}

845 
ut8_t
 
	$USART_Rx
(
USART_TyDef
 *
u
)

847 !(
u
->
STATUS
 & 
USART_STATUS_RXDATAV
))

850  (
ut8_t
)(
u
->
RXDATA
);

851 
	}
}

875 
ut16_t
 
	$USART_RxDoub
(
USART_TyDef
 *
u
)

877 !(
u
->
STATUS
 & 
USART_STATUS_RXFULL
))

880  (
ut16_t
)(
u
->
RXDOUBLE
);

881 
	}
}

905 
ut32_t
 
	$USART_RxDoubExt
(
USART_TyDef
 *
u
)

907 !(
u
->
STATUS
 & 
USART_STATUS_RXFULL
))

910  
u
->
RXDOUBLEX
;

911 
	}
}

935 
ut16_t
 
	$USART_RxExt
(
USART_TyDef
 *
u
)

937 !(
u
->
STATUS
 & 
USART_STATUS_RXDATAV
))

940  (
ut16_t
)(
u
->
RXDATAX
);

941 
	}
}

963 
ut8_t
 
	$USART_SpiTnsr
(
USART_TyDef
 *
u
, 
ut8_t
 
da
)

965 !(
u
->
STATUS
 & 
USART_STATUS_TXBL
));

966 
u
->
TXDATA
 = (
ut32_t
)
da
;

967 !(
u
->
STATUS
 & 
USART_STATUS_TXC
));

968  (
ut8_t
)(
u
->
RXDATA
);

969 
	}
}

995 
	$USART_Tx
(
USART_TyDef
 *
u
, 
ut8_t
 
da
)

998 !(
u
->
STATUS
 & 
USART_STATUS_TXBL
));

999 
u
->
TXDATA
 = (
ut32_t
)
da
;

1000 
	}
}

1030 
	$USART_TxDoub
(
USART_TyDef
 *
u
, 
ut16_t
 
da
)

1033 !(
u
->
STATUS
 & 
USART_STATUS_TXBL
))

1035 
u
->
TXDOUBLE
 = (
ut32_t
)
da
;

1036 
	}
}

1066 
	$USART_TxDoubExt
(
USART_TyDef
 *
u
, 
ut32_t
 
da
)

1069 !(
u
->
STATUS
 & 
USART_STATUS_TXBL
))

1071 
u
->
TXDOUBLEX
 = 
da
;

1072 
	}
}

1094 
	$USART_TxExt
(
USART_TyDef
 *
u
, 
ut16_t
 
da
)

1097 !(
u
->
STATUS
 & 
USART_STATUS_TXBL
))

1099 
u
->
TXDATAX
 = (
ut32_t
)
da
;

1100 
	}
}

	@C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\ADXL345.c

1 
	~"ADXL345.h
"

2 
	~"em_u.h
"

3 
	~"em_gpio.h
"

4 
	~"aivy_p.h
"

6 
	gvues
[10];

15 
	$wreRegi
(
giAddss
, 
vue
)

17 
	`GPIO_POutCˬ
(
ACCEL_CS_PORT
, 
ACCEL_CS_PIN
);

19 
	`USART_Tx

ACCEL_USART
, 
giAddss
);

20 
	`USART_Tx

ACCEL_USART
, 
vue
);

22 !(
	`USART_StusG

ACCEL_USART
 ) & 
USART_STATUS_TXC
));

24 
	`GPIO_POutS
(
ACCEL_CS_PORT
, 
ACCEL_CS_PIN
);

25 
	}
}

33 
	$adRegi
(
giAddss
, 
numBys
, * 
vues
)

35 
addss
 = 0x80 | 
giAddss
;

36 if(
numBys
 > 1)
addss
 =ddress | 0x40;

38 
	`GPIO_POutCˬ
(
ACCEL_CS_PORT
, 
ACCEL_CS_PIN
);

40 
ACCEL_USART
->
CMD
 |
USART_CMD_RXBLOCKEN
;

41 
	`USART_Tx

ACCEL_USART
, 
addss
 );

42 
ACCEL_USART
->
CMD
 |
USART_CMD_RXBLOCKDIS
;

44  
i
=0; i<
numBys
; i++ )

46 
	`USART_Tx

ACCEL_USART
, 
DUMMY
 );

47 !(
ACCEL_USART
->
STATUS
 & 
USART_STATUS_RXDATAV
));

48 
vues
[
i
] = 
	`USART_Rx

ACCEL_USART
 );

51 !(
	`USART_StusG

ACCEL_USART
 ) & 
USART_STATUS_TXC
));

53 
ACCEL_USART
->
CMD
 |
USART_CMD_RXBLOCKEN
;

54 
	`GPIO_POutS
(
ACCEL_CS_PORT
, 
ACCEL_CS_PIN
);

55 
	}
}

	@C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\ADXL345.h

1 #ide
ADXL345_H_INCLUDED


2 
	#ADXL345_H_INCLUDED


	)

9 
	#DEVID_ACCEL
 0x00

10 
	#THRESH_TAP
 0x1D

11 
	#OFSX
 0x1E

12 
	#OFSY
 0x1F

13 
	#OFSZ
 0x20

14 
	#DURATION
 0x21

15 
	#LATENT
 0x22

16 
	#WINDOW
 0x23

17 
	#THRESH_ACT
 0x24

18 
	#THRESH_INACT
 0x25

19 
	#TIME_INACT
 0x26

20 
	#ACT_INACT_CTL
 0x27

21 
	#THRESH_FF
 0x28

22 
	#TIME_FF
 0x29

23 
	#TAP_AXES
 0x2A

24 
	#ACT_TAP_STATUS
 0x2B

25 
	#BW_RATE
 0x2C

26 
	#POWER_CTL
 0x2D

27 
	#INT_ENABLE
 0x2E

28 
	#INT_MAP
 0x2F

29 
	#INT_SOURCE
 0x30

30 
	#DATA_FORMAT
 0x31

31 
	#DATAX0
 0x32

32 
	#DATAX1
 0x33

33 
	#DATAY0
 0x34

34 
	#DATAY1
 0x35

35 
	#DATAZ0
 0x36

36 
	#DATAZ1
 0x37

37 
	#FIFO_CTL
 0x38

38 
	#FIFO_STATUS
 0x39

39 
	#DUMMY
 0x00

40 
	#SENSITIVITY
 0x22

41 
	#ACT_INT_MASK
 0x10

42 
	#BAUDRATE
 10000

43 
	#INTS_PER_KM
 1205

44 

	)

45 
	#ACCEL_INT_PORT
 
gpioPtD


	)

46 
	#ACCEL_INT_PIN
 4

	)

48 
adRegi
(
giAddss
, 
numBys
, * 
vues
);

50 
wreRegi
(
giAddss
, 
vue
);

52 
vues
[10];

	@C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\activity_app.c

8 
	~"em_pt.h
"

9 
	~"em_cmu.h
"

10 
	~"em_gpio.h
"

11 
	~"em_emu.h
"

12 
	~"time_magemt.h
"

13 
	~"aivy_p.h
"

14 
	~"bus.h
"

15 
	~"ADXL345.h
"

16 
	~"gmcd.h
"

17 
	~"e_mache.h
"

19 
Cou
();

20 
dwAivySn
();

21 
PCNT1_IRQHdr
();

22 
SPI
();

23 
Acl
();

24 
AclIru
();

26 
ut16_t
 
	gaivy
[
MAX_WEEKS
][
WEEK_DAYS
];

27 
ut32_t
 
	gavage_aivy
;

37 
	$Cou
()

40 
	`CMU_ClockEb
(
cmuClock_CORELE
, 
ue
);

41 
	`CMU_ClockEb
(
cmuClock_GPIO
, 
ue
);

42 
	`CMU_ClockEb
(
cmuClock_PCNT1
, 
ue
);

45 
	`GPIO_PModeS
(
ACTIVITY_PORT
, 
ACTIVITY_PIN
, 
gpioModeIutPu
, 0);

48 
PCNT_In_TyDef
 
ptIn
 =

50 .
mode
 = 
ptModeOvsSg
,

51 .
cou
 = 0,

52 .
t
 = 10,

53 .
gEdge
 = 
l
,

54 .
couDown
 = 
l
,

55 .
fr
 = 
l
,

59 
	`PCNT_In
(
PCNT1
, &
ptIn
);

62 
	`PCNT_IEb
(
PCNT1
, 0x2);

65 
	`NVIC_EbIRQ
(
PCNT1_IRQn
);

68 
PCNT1
->
ROUTE
 = 
PCNT_ROUTE_LOCATION_LOC0
;

69 
	}
}

80 
	$Aivy
()

82 
	`Cou
();

85 
ut8_t
 
wk
 = 0; week < 52; week++)

87 
ut8_t
 
day
 = 0; day < 7; day++)

89 
aivy
[
wk
][
day
] = 0;

93 
avage_aivy
 = 0;

95 
	`SPI
();

96 
	`Acl
();

97 
	`AclIru
();

98 
	}
}

109 
	$AclIru
()

112 
	`GPIO_PModeS
(
ACCEL_INT_PORT
 , 
ACCEL_INT_PIN
, 
gpioModeIut
, 0);

113 
	`GPIO_ICfig
(
ACCEL_INT_PORT
, 
ACCEL_INT_PIN
, 
ue
, 
l
,rue);

116 
	`NVIC_CˬPdgIRQ
(
GPIO_EVEN_IRQn
);

117 
	`NVIC_EbIRQ
(
GPIO_EVEN_IRQn
);

118 
	}
}

129 
	$rAivy
(
ut8_t
 
wk
, ut8_
wday
)

131 
avage_aivy
 =vage_aivy * 6 / 7 + 
aivy
[
wk
][
wday
];

132 
aivy
[
wk
][
wday
] = 0;

133 
	}
}

144 
	$dwAivySn
()

146 
	`SegmtLCD_NumbOff
();

147 
	`SegmtLCD_Wre
("Actvty");

148 
	`SegmtLCD_Numb
(
aivy
[
cutTime
.
tm_wk
][cutTime.
tm_wday
]);

150 
	}
}

161 
	$aivyA
()

163 if
bu
 =
BUTTON_A
)

165 
bu
 = 
NO_BUTTON
;

166 
	`xtS
();

168 if(
bu
 =
BUTTON_B
)

170 
bu
 = 
NO_BUTTON
;

175 
bu
 = 
NO_BUTTON
;

176 
	`dwAivySn
();

177 
	`EMU_EEM2
(
ue
);

179 
	}
}

186 
	$PCNT1_IRQHdr
()

189 
	`PCNT_ICˬ
(
PCNT1
, 0x2);

191 
aivy
[
cutTime
.
tm_wk
][cutTime.
tm_wday
]++;

192 
	}
}

200 
	$Acl
()

202 
	`wreRegi
(
DATA_FORMAT
, 0x01);

203 
	`wreRegi
(
THRESH_ACT
, 
SENSITIVITY
);

204 
	`wreRegi
(
ACT_INACT_CTL
, 0x70);

205 
	`wreRegi
(
INT_ENABLE
, 0x10);

206 
	`wreRegi
(
INT_MAP
, 0x00);

208 
	`wreRegi
(
POWER_CTL
, 0x08);

210  !(
vues
[0] & 
ACT_INT_MASK
) )

212 
	`adRegi
(
INT_SOURCE
, 1, 
vues
);

214 
	}
}

223 
	$SPI
()

226 
	`CMU_ClockEb
(
CMUCLOCK_ACCEL_USART
, 
ue
);

229 
	`GPIO_PModeS

ACCEL_MOSI_PORT
, 
ACCEL_MOSI_PIN
, 
gpioModePushPu
, 0 );

230 
	`GPIO_PModeS

ACCEL_MISO_PORT
, 
ACCEL_MISO_PIN
, 
gpioModeIut
, 0 );

231 
	`GPIO_PModeS

ACCEL_CLK_PORT
, 
ACCEL_CLK_PIN
, 
gpioModePushPu
, 0 );

232 
	`GPIO_PModeS

ACCEL_CS_PORT
, 
ACCEL_CS_PIN
, 
gpioModePushPu
, 0 );

235 
USART_InSync_TyDef
 
uIn
 = 
USART_INITSYNC_DEFAULT
;

236 
uIn
.
baud
 = 
BAUDRATE
;

237 
uIn
.
msbf
 = 
ue
;

238 
uIn
.
ockMode
 = 
uClockMode3
;

240 
	`USART_InSync
(
ACCEL_USART
, &
uIn
);

243 
ACCEL_USART
->
ROUTE
 = (
USART_ROUTE_CLKPEN
 | 
USART_ROUTE_TXPEN
 | 
USART_ROUTE_RXPEN
 | 
ACCER_USART_LOC
);

244 
ACCEL_USART
->
CMD
 |
USART_CMD_RXBLOCKEN
;

245 
	}
}

257 
	$aivySuggei
()

259 
	`SegmtLCD_Wre
("Do More");

260 
sn_nifiti
 = 
ue
;

261 
	}
}

	@C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\activity_app.h

1 #ide
ACTIVITY_H_INCLUDED


2 
	#ACTIVITY_H_INCLUDED


	)

8 
	#ACTIVITY_PORT
 
gpioPtC


	)

9 
	#ACTIVITY_PIN
 4

	)

10 
	#ACTIVITY_COUNTER
 
cmuClock_PCNT1


	)

12 
	#ACCEL_USART
 
USART1


	)

13 
	#CMUCLOCK_ACCEL_USART
 
cmuClock_USART1


	)

14 
	#ACCEL_CS_PORT
 
gpioPtD


	)

15 
	#ACCEL_CS_PIN
 3

	)

16 
	#ACCEL_MOSI_PORT
 
gpioPtD


	)

17 
	#ACCEL_MOSI_PIN
 0

	)

18 
	#ACCEL_MISO_PORT
 
gpioPtD


	)

19 
	#ACCEL_MISO_PIN
 1

	)

20 
	#ACCEL_CLK_PORT
 
gpioPtD


	)

21 
	#ACCEL_CLK_PIN
 2

	)

22 
	#ACCER_USART_LOC
 
USART_ROUTE_LOCATION_LOC1


	)

24 
	#MAX_WEEKS
 52

25 
	#WEEK_DAYS
 7

26 

	)

27 
Aivy
();

28 
rAivy
(
ut8_t
 
wk
, ut8_
wday
);

29 
aivyA
();

30 
aivySuggei
();

	@C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\blink.c

35 
	~<dt.h
>

36 
	~<dbo.h
>

37 
	~"em_devi.h
"

38 
	~"em_ch.h
"

39 
	~"em_cmu.h
"

40 
	~"em_emu.h
"

41 
	~"b.h
"

42 
	~"b_a.h
"

43 
	~"e_mache.h
"

44 
	~"time_magemt.h
"

45 
	~"tup_time_p.h
"

46 
	~"bus.h
"

47 
	~"gmcd.h
"

48 
	~"pomodo_p.h
"

49 
	~"aivy_p.h
"

50 
	~"vbs.h
"

52 vީ
ut32_t
 
	gmsTicks
;

54 
Day
(
ut32_t
 
dlyTicks
);

60 
	$SysTick_Hdr
()

62 
msTicks
++;

63 
	}
}

70 
	$Day
(
ut32_t
 
dlyTicks
)

72 
ut32_t
 
curTicks
;

74 
curTicks
 = 
msTicks
;

75 (
msTicks
 - 
curTicks
< 
dlyTicks
) ;

76 
	}
}

86 
	$tupSWO
()

89 
CMU
->
HFPERCLKEN0
 |
CMU_HFPERCLKEN0_GPIO
;

91 
GPIO
->
ROUTE
 |
GPIO_ROUTE_SWOPEN
;

92 #i
	`defed
(
_EFM32_GIANT_FAMILY
|| defed(
_EFM32_WONDER_FAMILY
|| defed(
_EFM32_LEOPARD_FAMILY
)

94 
GPIO
->
ROUTE
 = (GPIO->ROUTE & ~(
_GPIO_ROUTE_SWLOCATION_MASK
)| 
GPIO_ROUTE_SWLOCATION_LOC0
;

97 
GPIO
->
P
[5].
MODEL
 &~(
_GPIO_P_MODEL_MODE2_MASK
);

98 
GPIO
->
P
[5].
MODEL
 |
GPIO_P_MODEL_MODE2_PUSHPULL
;

101 
GPIO
->
ROUTE
 = (GPIO->ROUTE & ~(
_GPIO_ROUTE_SWLOCATION_MASK
)| 
GPIO_ROUTE_SWLOCATION_LOC1
;

103 
GPIO
->
P
[2].
MODEH
 &~(
_GPIO_P_MODEH_MODE15_MASK
);

104 
GPIO
->
P
[2].
MODEH
 |
GPIO_P_MODEH_MODE15_PUSHPULL
;

107 
CMU
->
OSCENCMD
 = 
CMU_OSCENCMD_AUXHFRCOEN
;

109 !(
CMU
->
STATUS
 & 
CMU_STATUS_AUXHFRCORDY
));

112 
CeDebug
->
DHCSR
 |= 1;

113 
CeDebug
->
DEMCR
 |
CeDebug_DEMCR_TRCENA_Msk
;

116 
DWT
->
CTRL
 = 0x400113FF;

118 
TPI
->
ACPR
 = 0xf;

120 
TPI
->
SPPR
 = 2;

122 
ITM
->
LAR
 = 0xC5ACCE55;

123 
ITM
->
TCR
 = 0x10009;

124 
	}
}

133 
	$ma
()

136 
	`CHIP_In
();

139 
	`BSP_TProfSup
();

142 
	`tupSWO
();

144 
	`BSP_LedsIn
();

145 
	`Bus
();

146 
	`Clock
();

147 
	`Aivy
();

148 
	`Pedom
();

149 
	`Vbs
();

150 
	`SegmtLCD_In
(
l
);

152 
e
 = 
ma_sn
;

158 if(
sn_nifiti
 =
ue
)

160 
	`EMU_EEM2
(
ue
);

161 
bu
 = 
NO_BUTTON
;

165 
e
)

167 
ma_sn
:

168 
	`maSnA
();

170 
pomodo_sn
:

171 
	`pomodoA
();

173 
aivy_sn
:

174 
	`aivyA
();

176 
time_tup_sn
:

177 
	`tupTimeA
();

179 
m_tup_sn
:

180 
	`tupArmA
();

185 
	}
}

	@C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\buttons.c

8 
	~"em_gpio.h
"

9 
	~"em_cmu.h
"

10 
	~"e_mache.h
"

11 
	~"bus.h
"

12 
	~"time_magemt.h
"

13 
	~"ADXL345.h
"

15 vީ
ut8_t
 
	gbu
 = 
NO_BUTTON
;

26 
	$Bus
()

28 
	`CMU_ClockEb
(
cmuClock_GPIO
, 
ue
);

29 
	`GPIO_PModeS
(
BUTTON_A_PORT
, 
BUTTON_A_PIN
, 
gpioModeIut
, 1);

30 
	`GPIO_ICfig
(
BUTTON_A_PORT
, 
BUTTON_A_PIN
, 
l
, 
ue
,rue);

32 
	`GPIO_PModeS
(
BUTTON_B_PORT
, 
BUTTON_B_PIN
, 
gpioModeIut
, 1);

33 
	`GPIO_ICfig
(
BUTTON_B_PORT
, 
BUTTON_B_PIN
, 
l
, 
ue
,rue);

36 
	`NVIC_CˬPdgIRQ
(
GPIO_EVEN_IRQn
);

37 
	`NVIC_EbIRQ
(
GPIO_EVEN_IRQn
);

38 
	`NVIC_CˬPdgIRQ
(
GPIO_ODD_IRQn
);

39 
	`NVIC_EbIRQ
(
GPIO_ODD_IRQn
);

40 
	}
}

52 
	$GPIO_EVEN_IRQHdr
()

54 if(
	`GPIO_IG
(& (1 << 
BUTTON_B_PIN
))

56 
	`GPIO_ICˬ
(1 << 
BUTTON_B_PIN
);

57 
bu
 = 
BUTTON_B
;

58 
sn_nifiti
 = 
l
;

61 if(
	`GPIO_IG
(& (1 << 
ACCEL_INT_PIN
))

65 
	`GPIO_ICˬ
1 << 
ACCEL_INT_PIN
 );

67 
vues
[0] = 0;

68  !(
vues
[0] & 
ACT_INT_MASK
) )

70 
	`adRegi
(
INT_SOURCE
, 1, 
vues
);

77 
	}
}

89 
	$GPIO_ODD_IRQHdr
()

91 if(
	`GPIO_IG
(& (1 << 
BUTTON_A_PIN
))

93 
	`GPIO_ICˬ
(1 << 
BUTTON_A_PIN
);

94 
bu
 = 
BUTTON_A
;

95 
sn_nifiti
 = 
l
;

101 
	}
}

	@C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\buttons.h

1 #ide
BUTTONS_H_INCLUDED


2 
	#BUTTONS_H_INCLUDED


	)

7 
	#BUTTON_A_PORT
 
gpioPtB


	)

8 
	#BUTTON_A_PIN
 9

	)

10 
	#BUTTON_B_PORT
 
gpioPtB


	)

11 
	#BUTTON_B_PIN
 10

	)

13 
	#NO_BUTTON
 0

	)

14 
	#BUTTON_A
 1

	)

15 
	#BUTTON_B
 2

	)

16 
	#BUTTON_C
 3

	)

18 
	~"b.h
"

22 vީ
ut8_t
 
bu
;

25 
Bus
();

	@C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\globals.h

2 vީ
ut8_t
 
bu
;

3 vީ
ut32_t
 
time
;

	@C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\main_screen_app.c

8 
	~"time_magemt.h
"

9 
	~"aivy_p.h
"

10 
	~"bus.h
"

11 
	~"e_mache.h
"

12 
	~"gmcd.h
"

13 
	~"em_emu.h
"

23 
	$maSnA
()

25 if
bu
 =
BUTTON_A
)

27 
bu
 = 
NO_BUTTON
;

28 
	`xtS
();

30 if(
bu
 =
BUTTON_B
)

32 
bu
 = 
NO_BUTTON
;

37 
bu
 = 
NO_BUTTON
;

38 
	`SegmtLCD_Wre
("Main");

39 
	`EMU_EEM2
(
ue
);

41 
	}
}

	@C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\main_screen_app.h

1 #ide
MAIN_SCREEN_APP_H_INCLUDED


2 
	#MAIN_SCREEN_APP_H_INCLUDED


	)

8 
maSnA
();

	@C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\pedometer.c

9 
	~"em_tim.h
"

10 
	~"em_cmu.h
"

11 
	~"em_tim.h
"

12 
	~"aivy_p.h
"

13 
	~"ADXL345.h
"

15 
	#LETIMER_TOP
 12000

	)

16 
	#MIN_TIME
 10

	)

17 
	#MAX_TIME
 100

	)

19 
PedomTim
();

21 
ut8_t
 
	gaclDa
[100];

22 
ut32_t
 
	gs
 = 0;

32 
	$Pedom
()

35 
	`PedomTim
();

36 
	}
}

38 
	$PedomTim
()

47 
	`CMU_ClockEb
(
cmuClock_LETIMER0
, 
ue
);

50 
	`LETIMER_ComS
(
LETIMER0
, 0, 
LETIMER_TOP
);

52 
	`LETIMER_ICˬ
(
LETIMER0
, 0xFF);

53 
	`LETIMER_IEb
(
LETIMER0
, 4);

54 
	`NVIC_EbIRQ
(
LETIMER0_IRQn
);

57 cڡ 
LETIMER_In_TyDef
 
timIn
 =

59 .
ab
 = 
ue
,

60 .
debugRun
 = 
l
,

61 .
cComp0Eb
 = 
l
,

62 .
cComp1Eb
 = 
l
,

63 .
comp0T
 = 
ue
,

64 .
bufT
 = 
l
,

65 .
out0P
 = 0,

66 .
out1P
 = 0,

67 .
uf0
 = 
timUFOANe
,

68 .
uf1
 = 
timUFOANe
,

69 .
pMode
 = 
timRtFe


73 
	`LETIMER_In
(
LETIMER0
, &
timIn
);

74 
	}
}

77 
	$LETIMER0_IRQHdr
()

79 
ut8_t
 
i
 = 0;

80 
ut32_t
 
su
 = 0;

81 
ut32_t
 
dResu
 = 0;

82 
bo
 
adEdge
 = 
l
;

83 
ut16_t
 
timePasd
 = 0;

85 
	`LETIMER_ICˬ
(
LETIMER0
, 0xFF);

89 
	`adRegi
(
DATAX0
, 1, &
aclDa
[
i
]);

90 
su
 +
aclDa
[
i
];

91 
i
++;

93 if
i
 >= 4)

95 
i
 = 0;

96 
su
 /= 4;

98 
dResu
 = 
su
;

99 
su
 = 
aclDa
[
i
];

101 if(
adEdge
)

103 
timePasd
++;

105 if(
su
 < 
dResu
)

107 if(
MIN_TIME
 < 
timePasd
 < 
MAX_TIME
 )

109 
timePasd
 = 0;

110 
s
++;

112 
adEdge
 = 
l
;

118 if
su
 > 
dResu
)

120 
adEdge
 = 
ue
;

124 
	}
}

	@C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\pomodoro_app.c

10 
	~"b.h
"

11 
	~"time_magemt.h
"

12 
	~"e_mache.h
"

13 
	~"bus.h
"

14 
	~"pomodo_p.h
"

15 
	~"gmcd.h
"

16 
	~"em_emu.h
"

18 
updePomodoTime
(
ut8_t
 
time
);

19 
Pomodo
();

20 
dwPomodoSn
();

23 
bo
 
	gpomodo_timeout
 = 
l
;

25 
	epomodo_e_t


27 
	mpomodo_off
,

28 
	mpomodo_aive
,

29 
	mpomodo_sht_bke
,

30 
	mpomodo_lg_bke


32 
pomodo_e_t
 
	gpomodo_e
 = 
pomodo_off
;

43 
	$pomodoA
()

45 
ut8_t
 
pomodos
 = 0;

47 
pomodo_e
)

49 
pomodo_off
:

50 if(
bu
 =
BUTTON_B
)

52 
bu
 = 
NO_BUTTON
;

53 
	`updePomodoTime
(
POMODORO_WORK_TIME
);

54 
pomodo_e
 = 
pomodo_aive
;

57 
pomodo_aive
:

58 if(
bu
 =
BUTTON_B
)

60 
bu
 = 
NO_BUTTON
;

61 
pomodos
 = 0;

62 
	`Pomodo
();

64 if(
pomodo_timeout
 =
ue
)

66 
pomodo_timeout
 = 
l
;

67 
pomodos
++;

68 if(
pomodos
 >
POMODOROS_TO_LONG_BRAKE
)

70 
pomodos
 = 0;

71 
	`updePomodoTime
(
LONG_BRAKE_TIME
);

72 
pomodo_e
 = 
pomodo_lg_bke
;

76 
	`updePomodoTime
(
SHORT_BRAKE_TIME
);

77 
pomodo_e
 = 
pomodo_sht_bke
;

81 
pomodo_sht_bke
:

82 if(
bu
 =
BUTTON_B
)

84 
bu
 = 
NO_BUTTON
;

85 
	`Pomodo
();

87 if(
pomodo_timeout
 =
ue
)

89 
pomodo_timeout
 = 
l
;

90 
	`updePomodoTime
(
POMODORO_WORK_TIME
);

91 
pomodo_e
 = 
pomodo_aive
;

94 
pomodo_lg_bke
:

95 if(
bu
 =
BUTTON_B
)

97 
bu
 = 
NO_BUTTON
;

98 
	`Pomodo
();

100 if(
pomodo_timeout
 =
ue
)

102 
pomodo_timeout
 = 
l
;

103 
	`updePomodoTime
(
POMODORO_WORK_TIME
);

104 
pomodo_e
 = 
pomodo_aive
;

109 if
bu
 =
BUTTON_A
)

111 
bu
 = 
NO_BUTTON
;

112 
	`xtS
();

116 
bu
 = 
NO_BUTTON
;

117 
	`dwPomodoSn
();

118 
	`EMU_EEM2
(
ue
);

120 
	}
}

131 
	$dwPomodoSn
()

133 
pomodo_e
)

135 
pomodo_aive
:

136 
	`SegmtLCD_Wre
("Work");

138 
pomodo_sht_bke
:

139 
	`SegmtLCD_Wre
("Break");

141 
pomodo_lg_bke
:

142 
	`SegmtLCD_Wre
("Break");

144 
pomodo_off
:

145 
	`SegmtLCD_Wre
("OFF");

148 
t8_t
 
time_befe_xt_e
 = 
pomodo
.
tm_m
 - 
cutTime
.tm_min;

149 if(
time_befe_xt_e
 < 0)

151 
time_befe_xt_e
 += 59;

153 if(
pomodo_e
 !
pomodo_off
)

155 
	`SegmtLCD_Numb
(
time_befe_xt_e
);

159 
	`SegmtLCD_NumbOff
();

161 
	}
}

172 
	$updePomodoTime
(
ut8_t
 
time
)

174 
pomodo
.
aive
 = 
ue
;

175 
pomodo
.
tm_c
 = 
cutTime
.tm_sec;

177 if(
cutTime
.
tm_m
 + 
time
 >= 59)

179 
pomodo
.
tm_m
 = 
cutTime
.tm_m + 
time
 - 59;

180 
pomodo
.
tm_hour
 = 
cutTime
.tm_hour;

181 
	`emtPot
(
hours
, &
pomodo
);

182 
pomodo
.
tm_wday
 = 0;

186 
pomodo
.
tm_m
 = 
cutTime
.tm_m + 
time
;

187 
pomodo
.
tm_hour
 = 
cutTime
.tm_hour;

189 
	}
}

200 
	$Pomodo
()

202 
pomodo_e
 = 
pomodo_off
;

203 
pomodo
.
aive
 = 
l
;

204 
	}
}

216 
	$checkPomodo
()

218 if(
pomodo
.
aive
 &&

219 (
pomodo
.
tm_c
 <
cutTime
.tm_sec) &&

220 (
pomodo
.
tm_m
 <
cutTime
.tm_min) &&

221 (
pomodo
.
tm_hour
 =
cutTime
.tm_hour))

223 
pomodo_timeout
 = 
ue
;

224 
e
 = 
pomodo_sn
;

226 
	}
}

	@C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\pomodoro_app.h

1 #ide
POMODORO_H_INCLUDED


2 
	#POMODORO_H_INCLUDED


	)

8 
	#POMODORO_WORK_TIME
 25

	)

9 
	#SHORT_BRAKE_TIME
 5

	)

10 
	#LONG_BRAKE_TIME
 25

	)

11 
	#POMODOROS_TO_LONG_BRAKE
 4

	)

13 
checkPomodo
();

14 
pomodoA
();

	@C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\setup_alarm_app.c

10 
	~"bus.h
"

11 
	~"tup_time_p.h
"

12 
	~"time_magemt.h
"

13 
	~"gmcd.h
"

14 
	~"e_mache.h
"

15 
	~"em_emu.h
"

17 
	#FIRST_SETUP_STATE
 
mus


	)

18 
	#LAST_SETUP_STATE
 
aive


	)

21 
tm
 * 
	gp_m
 = &
m1
;

24 
dwSupArmSn
();

25 
xtArmSupS
();

26 
dwSupArmSn
();

37 
	$tupArmA
()

39 if
bu
 =
BUTTON_A
)

41 
bu
 = 
NO_BUTTON
;

42 
	`xtS
();

44 if(
bu
 =
BUTTON_B
)

46 
bu
 = 
NO_BUTTON
;

47 
	`xtArmSupS
();

49 if(
bu
 =
BUTTON_C
)

51 
bu
 = 
NO_BUTTON
;

53 if(
ock_tup_e
 =
aive
)

55 if(
p_m
->
aive
 =
ue
)

57 
p_m
->
aive
 = 
l
;

61 
p_m
->
aive
 = 
ue
;

66 
	`emtPot
(
ock_tup_e
, 
p_m
);

71 
bu
 = 
NO_BUTTON
;

72 
	`dwSupArmSn
();

73 
	`EMU_EEM2
(
ue
);

75 
	}
}

86 
	$xtArmSupS
()

88 if(
ock_tup_e
 =
LAST_SETUP_STATE
)

90 
ock_tup_e
 = 
FIRST_SETUP_STATE
;

94 
ock_tup_e
++;

96 
	}
}

107 
	$dwSupArmSn
()

109 
	`SegmtLCD_NumbOff
();

110 if(
p_m
 =&
m1
)

112 
	`SegmtLCD_Wre
("Alarm_1");

116 
	`SegmtLCD_Wre
("Alarm_2");

118 
	}
}

	@C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\setup_time_app.c

10 
	~"bus.h
"

11 
	~"tup_time_p.h
"

12 
	~"b.h
"

13 
	~"time_magemt.h
"

14 
	~"e_mache.h
"

15 
	~"gmcd.h
"

16 
	~"em_emu.h
"

18 
	#FIRST_SETUP_STATE
 
mus


	)

19 
	#LAST_SETUP_STATE
 
wk_days


	)

21 
xtTimeSupS
();

23 
tup_e_t
 
	gock_tup_e
;

34 
	$tupTimeA
()

36 if
bu
 =
BUTTON_A
)

38 
bu
 = 
NO_BUTTON
;

39 
	`xtS
();

41 if(
bu
 =
BUTTON_B
)

43 
bu
 = 
NO_BUTTON
;

44 
	`xtTimeSupS
();

46 if(
bu
 =
BUTTON_C
)

48 
bu
 = 
NO_BUTTON
;

49 
	`emtPot
(
ock_tup_e
, &
cutTime
);

53 
	`SegmtLCD_NumbOff
();

54 
bu
 = 
NO_BUTTON
;

55 
	`SegmtLCD_Wre
("Setup_T");

56 
	`EMU_EEM2
(
ue
);

58 
	}
}

70 
	$xtTimeSupS
()

72 if(
ock_tup_e
 =
wk_days
)

74 
ock_tup_e
 = 
mus
;

78 
ock_tup_e
++;

80 
	}
}

	@C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\setup_time_app.h

1 #ide
SETUP_TIME_APP_H_INCLUDED


2 
	#SETUP_TIME_APP_H_INCLUDED


	)

8 
tupTimeA
();

9 
tupArmA
();

	@C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\state_machine.c

10 
	~"b.h
"

11 
	~"e_mache.h
"

12 
	~"bus.h
"

13 
	~"time_magemt.h
"

14 
	~"aivy_p.h
"

15 
	~"ma_sn_p.h
"

18 vީ
e_mache
 
	ge
 = 
ma_sn
;

30 
	$xtS
()

32 i(
e
 =
LAST_STATE
)

34 
e
 = 
FIRST_STATE
;

38 
e
++;

41 
ock_tup_e
 = 1;

42 
	}
}

53 
	$eviousS
()

55 i(
e
 =
FIRST_STATE
)

57 
e
 = 
LAST_STATE
;

61 
e
--;

63 
	}
}

	@C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\state_machine.h

1 
	#FIRST_STATE
 
ma_sn


	)

2 
	#LAST_STATE
 
m_tup_sn


	)

5 
	ee_mache


7 
	mma_sn
,

8 
	mpomodo_sn
,

9 
	maivy_sn
,

10 
	mtime_tup_sn
,

11 
	mm_tup_sn


14 vީ
e_mache
 
e
;

17 
maSnA
();

18 
xtS
();

19 
eviousS
();

	@C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\time_management.c

8 
	~"em_c.h
"

9 
	~"em_cmu.h
"

10 
	~"time_magemt.h
"

11 
	~"pomodo_p.h
"

12 
	~"gmcd.h
"

13 
	~"aivy_p.h
"

17 
	#RTC_COUNT_BETWEEN_WAKEUP
 1

18 

	)

19 
ut8_t
 
checkArms
();

20 
runArm
(
ut8_t
 
m
);

21 
updeTime
();

23 
tm
 
	gcutTime
;

24 
tm
 
	gm1
;

25 
tm
 
	gm2
;

26 
tm
 
	gpomodo
;

27 
bo
 
	gsn_nifiti
 = 
l
;

38 
	$Clock
()

42 
	`CMU_OsctEb
(
cmuOsc_LFXO
, 
ue
,rue);

45 
	`CMU_ClockSeS
(
cmuClock_LFA
,
cmuSe_LFXO
);

46 
	`CMU_ClockEb
(
cmuClock_RTC
, 
ue
);

48 
	`CMU_ClockEb
(
cmuClock_CORELE
, 
ue
);

52 
	`CMU_ClockDivS
(
cmuClock_RTC
,
cmuClkDiv_32768
);

53 
	`RTC_ComS
(0, 
RTC_COUNT_BETWEEN_WAKEUP
);

54 
	`RTC_IEb
(
RTC_IFC_COMP0
);

57 
	`NVIC_EbIRQ
(
RTC_IRQn
);

59 
RTC_In_TyDef
 
cIn
 = 
RTC_INIT_DEFAULT
;

60 
	`RTC_In
(&
cIn
);

61 
	}
}

72 
	$RTC_IRQHdr
()

74 
	`RTC_ICˬ
(
RTC_IF_COMP0
);

75 
	`updeTime
();

77 
ut8_t
 
m
 = 
	`checkArms
();

78 if(
m
)

80 
	`runArm
(
m
);

83 
	`checkPomodo
();

84 
	}
}

95 
	$updeTime
()

97 
	`emtPot
(
cds
, &
cutTime
);

98 
	}
}

109 
ut8_t
 
	$checkArms
()

111 if((
m1
.
tm_c
 =
cutTime
.tm_sec) &&

112 (
m1
.
tm_m
 =
cutTime
.tm_min) &&

113 (
m1
.
tm_hour
 =
cutTime
.tm_hour) &&

114 ((
m1
.
tm_wday
 =
cutTime
.tm_wday) ||larm1.tm_wday == 8) &&

115 (
m1
.
aive
))

120 if((
m2
.
tm_c
 =
cutTime
.tm_sec) &&

121 (
m2
.
tm_m
 =
cutTime
.tm_min) &&

122 (
m2
.
tm_hour
 =
cutTime
.tm_hour) &&

123 ((
m2
.
tm_wday
 =
cutTime
.tm_wday) ||larm2.tm_wday == 8) &&

124 (
m2
.
aive
))

130 
	}
}

142 
	$runArm
(
ut8_t
 
m
)

144 
m
)

147 
m
 = 0;

148 
m1
.
aive
 = 
l
;

149 
	`SegmtLCD_Wre
("ALARM 1");

150 
sn_nifiti
 = 
ue
;

153 
m
 = 0;

154 
m2
.
aive
 = 
l
;

155 
	`SegmtLCD_Wre
("ALARM 2");

156 
sn_nifiti
 = 
ue
;

159 
	}
}

171 
	$emtPot
(
tup_e_t
 
pots
, 
tm
 *
somhg
)

173 
pots
)

175 
cds
:

176 
somhg
->
tm_c
++;

177 
somhg
->
tm_c
++;

178 i(
somhg
->
tm_c
 < 60)

184 
somhg
->
tm_c
 = 0;

186 
mus
:

187 
somhg
->
tm_m
++;

188 i(
somhg
->
tm_m
 < 60)

194 
somhg
->
tm_m
 = 0;

196 
hours
:

197 
somhg
->
tm_hour
++;

198 i(
somhg
->
tm_hour
 < 24)

204 
somhg
->
tm_hour
 = 0;

206 
wk_days
:

207 
somhg
->
tm_wday
++;

208 if(
somhg
->
tm_wday
 >= 7)

210 
somhg
->
tm_wday
 = 0;

211 
somhg
->
tm_wk
++;

212 if(
somhg
->
tm_wk
 >= 52)

214 
somhg
->
tm_wk
 = 0;

218 if(
pots
 !
wk_days
)

220 
	`rAivy
(
somhg
->
tm_wk
, somhg->
tm_wday
);

221 if((
somhg
->
tm_wday
 == 6) ||(something->tm_wday == 5))

223 
	`aivySuggei
();

227 
aive
:

228 if(
somhg
->
aive
)

230 
somhg
->
aive
 = 
l
;

234 
somhg
->
aive
 = 
ue
;

237 
	}
}

249 
	$deemtPot
(
tup_e_t
 
pots
, 
tm
 *
somhg
)

251 
pots
)

253 
cds
:

254 
somhg
->
tm_c
--;

255 i(
somhg
->
tm_c
 >= 0)

261 
somhg
->
tm_c
 = 59;

263 
mus
:

264 
somhg
->
tm_m
--;

265 i(
somhg
->
tm_m
 >= 0)

271 
somhg
->
tm_m
 = 59;

273 
hours
:

274 
somhg
->
tm_hour
--;

275 i(
somhg
->
tm_hour
 >= 0)

281 
somhg
->
tm_hour
 = 23;

283 
wk_days
:

284 
somhg
->
tm_wday
--;

285 i(
somhg
->
tm_wday
 < 0)

287 
somhg
->
tm_wday
 = 6;

288 
somhg
->
tm_wk
--;

289 if(
somhg
->
tm_wk
 <= 0)

291 
somhg
->
tm_wk
 = 51;

295 if(
pots
 !
wk_days
)

297 
	`rAivy
(
somhg
->
tm_wk
, somhg->
tm_wday
);

298 if((
somhg
->
tm_wday
 == 6) ||(something->tm_wday == 5))

300 
	`aivySuggei
();

305 
	}
}

	@C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\time_management.h

1 #ide
CLOCK_H_INCLUDED


2 
	#CLOCK_H_INCLUDED


	)

9 
	~"b.h
"

12 
tm
 
cutTime
;

13 
tm
 
m1
;

14 
tm
 
m2
;

15 
tm
 
pomodo
;

16 
bo
 
sn_nifiti
;

19 
	stm


22 
ut8_t
 
	mtm_c
;

23 
ut8_t
 
	mtm_m
;

24 
ut8_t
 
	mtm_hour
;

25 
ut8_t
 
	mtm_wday
;

26 
ut8_t
 
	mtm_wk
;

27 
bo
 
	maive
;

30 
tup_e_t
 
ock_tup_e
;

31 
	etup_e_t
 { 
	mcds
,

32 
	mmus
,

33 
	mhours
,

34 
	mwk_days
,

35 
	maive


39 
Clock
();

40 
emtPot
(
tup_e_t
 
pots
, 
tm
 *
somhg
);

41 
deemtPot
(
tup_e_t
 
pots
, 
tm
 *
somhg
);

	@C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\variables.c

10 
	~"time_magemt.h
"

11 
	~<dbo.h
>

23 
	$Vbs
()

25 
cutTime
.
tm_c
 = 0;

26 
cutTime
.
tm_m
 = 0;

27 
cutTime
.
tm_hour
 = 0;

28 
cutTime
.
tm_wday
 = 0;

29 
cutTime
.
aive
 = 
l
;

31 
m1
.
tm_c
 = 10;

32 
m1
.
tm_m
 = 0;

33 
m1
.
tm_hour
 = 0;

34 
m1
.
tm_wday
 = 0;

35 
m1
.
aive
 = 
l
;

37 
m2
.
tm_c
 = 7;

38 
m2
.
tm_m
 = 0;

39 
m2
.
tm_hour
 = 0;

40 
m2
.
tm_wday
 = 8;

41 
m2
.
aive
 = 
l
;

43 
pomodo
.
tm_c
 = 30;

44 
pomodo
.
tm_m
 = 0;

45 
pomodo
.
tm_hour
 = 0;

46 
pomodo
.
tm_wday
 = 0;

47 
pomodo
.
aive
 = 
l
;

48 
	}
}

	@C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\variables.h

1 #ide
VARIABLES_H_INCLUDED


2 
	#VARIABLES_H_INCLUDED


	)

8 
Vbs
();

	@C:\Users\Alexander\AppData\Roaming\energymicro\kits\common\bsp\bsp_bcc.c

35 
	~<rg.h
>

36 
	~"em_devi.h
"

37 
	~"em_cmu.h
"

38 
	~"em_gpio.h
"

39 
	~"em_u.h
"

41 
	~"b.h
"

43 #i
defed

BSP_STK
 )

48 
USART_InAsync_TyDef
 
	guIn
 = 
USART_INITASYNC_DEFAULT
;

49 
ut32_t
 
	grxByCou
;

50 
ut32_t
 
	gtxByCou
;

53 
TxBy

ut8_t
 
da
 );

54 
ut8_t
 
RxBy
( );

74 
	$BSP_BccDeIn
( )

77 
rxByCou
 = 0xFFFFFFFFUL;

78 
txByCou
 = 0xFFFFFFFFUL;

81 
	`GPIO_PModeS

BSP_BCC_USART_TXPORT
, 
BSP_BCC_USART_TXPIN
,

82 
gpioModeIut
, 0 );

85 
	`GPIO_PModeS

BSP_BCC_USART_RXPORT
, 
BSP_BCC_USART_RXPIN
,

86 
gpioModeIut
, 0 );

90 
	`GPIO_PModeS

BSP_BCC_U602A_PORT
, 
BSP_BCC_U602A_PIN
,

91 
gpioModeIut
, 0 );

94 
	`USART_Ret

BSP_BCC_USART
 );

97 
	`CMU_ClockEb

BSP_BCC_USART_CLK
, 
l
 );

99  
BSP_STATUS_OK
;

100 
	}
}

108 
	$BSP_BccIn
( )

110 
rxByCou
 = 0;

111 
txByCou
 = 0;

114 
	`CMU_ClockEb
(
cmuClock_HFPER
, 
ue
);

117 
	`CMU_ClockEb
(
cmuClock_GPIO
, 
ue
);

121 
	`GPIO_PModeS

BSP_BCC_USART_TXPORT
, 
BSP_BCC_USART_TXPIN
,

122 
gpioModePushPu
, 1 );

125 
	`GPIO_PModeS

BSP_BCC_USART_RXPORT
, 
BSP_BCC_USART_RXPIN
,

126 
gpioModeIut
, 1 );

130 
	`GPIO_PModeS

BSP_BCC_U602A_PORT
, 
BSP_BCC_U602A_PIN
,

131 
gpioModePushPu
, 1 );

133 
	`CMU_ClockEb

BSP_BCC_USART_CLK
, 
ue
 );

136 
	`USART_InAsync

BSP_BCC_USART
, &
uIn
 );

139 
BSP_BCC_USART
->
ROUTE
 = 
USART_ROUTE_RXPEN
 | 
USART_ROUTE_TXPEN
 |

140 
BSP_BCC_USART_LOCATION
;

142  
BSP_STATUS_OK
;

143 
	}
}

152 
bo
 
	$BSP_BccPackReive

BCP_Pack
 *
pkt
 )

154 
i
;

155 
ngth
;

156 
ut8_t
 *
br
;

159 
br
 = (
ut8_t
 *
pkt
;

162 *
br
++ = 
	`RxBy
();

163 i(
pkt
->
magic
 !
BSP_BCP_MAGIC
)

165  
l
;

169 *
br
++ = 
	`RxBy
();

170 i(
pkt
->
ty
 < 
BSP_BCP_FIRST
|| (pkt->ty > 
BSP_BCP_LAST
) )

172  
l
;

176 *
br
++ = 
	`RxBy
();

177 i(
pkt
->
yldLgth
 > 
BSP_BCP_PACKET_SIZE
)

179  
l
;

182 #i
BSP_BCP_VERSION
 == 2 )

184 *
br
++ = 
	`RxBy
();

188 
ngth
 = 
pkt
->
yldLgth
;

189 i(
ngth
 > 
BSP_BCP_PACKET_SIZE
)

191 
ngth
 = 
BSP_BCP_PACKET_SIZE
;

195  
i
=0; i<
ngth
; i++ )

197 *
br
++ = 
	`RxBy
();

200  
ue
;

201 
	}
}

210 
	$BSP_BccPackSd

BCP_Pack
 *
pkt
 )

212 
i
;

215 
pkt
->
magic
 = 
BSP_BCP_MAGIC
;

218 
	`TxBy

pkt
->
magic
 );

221 
	`TxBy

pkt
->
ty
 );

224 
	`TxBy

pkt
->
yldLgth
 );

226 #i
BSP_BCP_VERSION
 == 2 )

228 
	`TxBy

pkt
->
rved
 );

232  
i
=0; i<
pkt
->
yldLgth
; i++ )

234 
	`TxBy

pkt
->
da
[
i
] );

237  
BSP_STATUS_OK
;

238 
	}
}

246 
USART_TyDef
 *
	$BSP_BccUG
( )

248  
BSP_BCC_USART
;

249 
	}
}

253 
ut8_t
 
	$RxBy
( )

255 
ut8_t
 
by
;

258 !(
BSP_BCC_USART
->
STATUS
 & 
USART_STATUS_RXDATAV
)) ;

259 
by
 = 
BSP_BCC_USART
->
RXDATA
;

260 
rxByCou
++;

261  
by
;

262 
	}
}

264 
	$TxBy

ut8_t
 
da
 )

267 !(
BSP_BCC_USART
->
STATUS
 & 
USART_STATUS_TXBL
)) ;

268 
BSP_BCC_USART
->
TXDATA
 = (
ut32_t

da
;

269 
txByCou
++;

270 
	}
}

	@C:\Users\Alexander\AppData\Roaming\energymicro\kits\common\bsp\bsp_stk.c

35 
	~<rg.h
>

36 
	~"em_devi.h
"

37 
	~"em_cmu.h
"

38 
	~"em_gpio.h
"

39 
	~"b.h
"

40 #i
defed

BSP_STK_USE_EBI
 )

41 
	~"em_ebi.h
"

44 #i
defed

BSP_STK
 )

64 
	$BSP_Dib
()

66 
	`BSP_BccDeIn
();

67 
	`BSP_EbiDeIn
();

69  
BSP_STATUS_OK
;

70 
	}
}

81 
	$BSP_EbiIn
()

83 #i
	`defed

BSP_STK_USE_EBI
 )

89 
EBI_In_TyDef
 
ebiCfig
 =

91 
ebiModeD8A8
,

92 
ebiAiveLow
,

93 
ebiAiveLow
,

94 
ebiAiveLow
,

95 
ebiAiveLow
,

96 
ebiAiveLow
,

97 
ebiAiveLow
,

98 
l
,

99 
ue
,

100 
l
,

101 
ue
,

102 
EBI_BANK0
,

106 
l
,

110 
l
,

111 
l
,

112 
l
,

116 
l
,

117 
l
,

118 
ebiALowA24
,

119 
ebiAHighA26
,

120 
ebiLoti1
,

121 
ue
,

125 
	`CMU_ClockEb
(
cmuClock_HFPER
, 
ue
);

126 
	`CMU_ClockEb
(
cmuClock_GPIO
, 
ue
);

127 
	`CMU_ClockEb
(
cmuClock_EBI
, 
ue
);

131 
	`GPIO_PModeS
(
gpioPtC
, 1, 
gpioModePushPu
, 0);

132 
	`GPIO_PModeS
(
gpioPtC
, 2, 
gpioModePushPu
, 0);

135 
	`GPIO_PModeS
(
gpioPtD
, 13, 
gpioModePushPu
, 0);

136 
	`GPIO_PModeS
(
gpioPtD
, 14, 
gpioModePushPu
, 1);

137 
	`GPIO_PModeS
(
gpioPtD
, 15, 
gpioModeIut
, 0);

140 
	`GPIO_PModeS
(
gpioPtE
, 8, 
gpioModePushPu
, 0);

141 
	`GPIO_PModeS
(
gpioPtE
, 9, 
gpioModePushPu
, 0);

142 
	`GPIO_PModeS
(
gpioPtE
, 10, 
gpioModePushPu
, 0);

143 
	`GPIO_PModeS
(
gpioPtE
, 11, 
gpioModePushPu
, 0);

144 
	`GPIO_PModeS
(
gpioPtE
, 12, 
gpioModePushPu
, 0);

145 
	`GPIO_PModeS
(
gpioPtE
, 13, 
gpioModePushPu
, 0);

146 
	`GPIO_PModeS
(
gpioPtE
, 14, 
gpioModePushPu
, 0);

147 
	`GPIO_PModeS
(
gpioPtE
, 15, 
gpioModePushPu
, 0);

150 
	`GPIO_PModeS
(
gpioPtF
, 8, 
gpioModePushPu
, 1);

151 
	`GPIO_PModeS
(
gpioPtF
, 9, 
gpioModePushPu
, 1);

154 
	`GPIO_PModeS
(
gpioPtB
, 15, 
gpioModePushPu
, 1);

156 
	`EBI_In
(&
ebiCfig
);

157 
EBI
->
NANDCTRL
 = (
EBI_NANDCTRL_BANKSEL_BANK0
 | 
EBI_NANDCTRL_EN
);

159  
BSP_STATUS_OK
;

161  
BSP_STATUS_NOT_IMPLEMENTED
;

163 
	}
}

175 
	$BSP_EbiDeIn
( )

177 #i
	`defed

BSP_STK_USE_EBI
 )

178  
BSP_STATUS_OK
;

180  
BSP_STATUS_NOT_IMPLEMENTED
;

182 
	}
}

193 
	$BSP_In

ut32_t
 
ags
 )

195 i
ags
 & 
BSP_INIT_BCC
 )

197 
	`BSP_BccIn
();

200  
BSP_STATUS_OK
;

201 
	}
}

214 
	$BSP_CutG
( )

216 
BCP_Pack
 
pkt
;

217 *
pcut
;

219 
pkt
.
ty
 = 
BSP_BCP_CURRENT_REQ
;

220 
pkt
.
yldLgth
 = 0;

223 
	`BSP_BccPackSd
&
pkt
 );

224 
	`BSP_BccPackReive
&
pkt
 );

227 
pcut
 = (*)
pkt
.
da
;

228 i
pkt
.
ty
 !
BSP_BCP_CURRENT_REPLY
 )

230 *
pcut
 = 0.0f;

233  *
pcut
;

234 
	}
}

246 
	$BSP_VޏgeG
( )

248 
BCP_Pack
 
pkt
;

249 *
pvޏge
;

251 
pkt
.
ty
 = 
BSP_BCP_VOLTAGE_REQ
;

252 
pkt
.
yldLgth
 = 0;

255 
	`BSP_BccPackSd
&
pkt
 );

256 
	`BSP_BccPackReive
&
pkt
 );

259 
pvޏge
 = (*)
pkt
.
da
;

260 i
pkt
.
ty
 !
BSP_BCP_VOLTAGE_REPLY
 )

262 *
pvޏge
 = 0.0f;

265  *
pvޏge
;

266 
	}
}

	@C:\Users\Alexander\AppData\Roaming\energymicro\kits\common\bsp\bsp_stk_leds.c

35 
	~"em_devi.h
"

36 
	~"em_cmu.h
"

37 
	~"em_gpio.h
"

38 
	~"b.h
"

40 #i
defed

BSP_GPIO_LEDS
 )

45 
GPIO_Pt_TyDef
 
	mpt
;

46 
	mp
;

47 } 
	ttLedAay
;

49 cڡ 
tLedAay
 
	gdAay
[ 
BSP_NO_OF_LEDS
 ] = 
BSP_GPIO_LEDARRAY_INIT
;

51 
	$BSP_LedsIn
()

53 
i
;

55 
	`CMU_ClockEb
(
cmuClock_HFPER
, 
ue
);

56 
	`CMU_ClockEb
(
cmuClock_GPIO
, 
ue
);

57  
i
=0; i<
BSP_NO_OF_LEDS
; i++ )

59 
	`GPIO_PModeS
(
dAay
[
i
].
pt
,edAay[i].
p
, 
gpioModePushPu
, 0);

61  
BSP_STATUS_OK
;

62 
	}
}

64 
ut32_t
 
	$BSP_LedsG
()

66 
i
;

67 
ut32_t
 
tV
, 
mask
;

69  
i
=0, 
tV
=0, 
mask
=0x1; i<
BSP_NO_OF_LEDS
; i++, mask <<= 1 )

71 i(
	`GPIO_POutG
(
dAay
[
i
].
pt
,edAay[i].
p
))

72 
tV
 |
mask
;

74  
tV
;

75 
	}
}

77 
	$BSP_LedsS
(
ut32_t
 
ds
)

79 
i
;

80 
ut32_t
 
mask
;

82  
i
=0, 
mask
=0x1; i<
BSP_NO_OF_LEDS
; i++, mask <<= 1 )

84 i
ds
 & 
mask
 )

85 
	`GPIO_POutS
(
dAay
[
i
].
pt
,edAay[i].
p
);

87 
	`GPIO_POutCˬ
(
dAay
[
i
].
pt
,edAay[i].
p
);

89  
BSP_STATUS_OK
;

90 
	}
}

92 
	$BSP_LedCˬ
(
dNo
)

94 i((
dNo
 >0&& (dN< 
BSP_NO_OF_LEDS
))

96 
	`GPIO_POutCˬ
(
dAay
[
dNo
].
pt
,edAay[dNo].
p
);

97  
BSP_STATUS_OK
;

99  
BSP_STATUS_ILLEGAL_PARAM
;

100 
	}
}

102 
	$BSP_LedG
(
dNo
)

104 
tV
 = 
BSP_STATUS_ILLEGAL_PARAM
;

106 i((
dNo
 >0&& (dN< 
BSP_NO_OF_LEDS
))

108 
tV
 = ()
	`GPIO_POutG
(
dAay
[
dNo
].
pt
,edAay[dNo].
p
);

110  
tV
;

111 
	}
}

113 
	$BSP_LedS
(
dNo
)

115 i((
dNo
 >0&& (dN< 
BSP_NO_OF_LEDS
))

117 
	`GPIO_POutS
(
dAay
[
dNo
].
pt
,edAay[dNo].
p
);

118  
BSP_STATUS_OK
;

120  
BSP_STATUS_ILLEGAL_PARAM
;

121 
	}
}

123 
	$BSP_LedTogg
(
dNo
)

125 i((
dNo
 >0&& (dN< 
BSP_NO_OF_LEDS
))

127 
	`GPIO_POutTogg
(
dAay
[
dNo
].
pt
,edAay[dNo].
p
);

128  
BSP_STATUS_OK
;

130  
BSP_STATUS_ILLEGAL_PARAM
;

131 
	}
}

	@C:\Users\Alexander\AppData\Roaming\energymicro\kits\common\bsp\bsp_trace.c

35 
	~<dbo.h
>

36 
	~"em_devi.h
"

37 
	~"em_gpio.h
"

38 
	~"em_cmu.h
"

39 
	~"b_a.h
"

40 
	~"b.h
"

42 #i
defed
(
BSP_ETM_TRACE
&& defed
ETM_PRESENT
 )

47 
	$BSP_TEtmSup
()

50 
CMU
->
HFCORECLKEN0
 |
CMU_HFCORECLKEN0_LE
;

51 
CMU
->
HFPERCLKEN0
 |
CMU_HFPERCLKEN0_GPIO
;

52 
CMU
->
OSCENCMD
 = 
CMU_OSCENCMD_AUXHFRCOEN
;

55 !(
CMU
->
STATUS
 & 
CMU_STATUS_AUXHFRCORDY
)) ;

58 
GPIO
->
P
[3].
MODEL
 = (GPIO->P[3].MODEL & ~
_GPIO_P_MODEL_MODE3_MASK
| 
GPIO_P_MODEL_MODE3_PUSHPULL
;

59 
GPIO
->
P
[3].
MODEL
 = (GPIO->P[3].MODEL & ~
_GPIO_P_MODEL_MODE4_MASK
| 
GPIO_P_MODEL_MODE4_PUSHPULL
;

60 
GPIO
->
P
[3].
MODEL
 = (GPIO->P[3].MODEL & ~
_GPIO_P_MODEL_MODE5_MASK
| 
GPIO_P_MODEL_MODE5_PUSHPULL
;

61 
GPIO
->
P
[3].
MODEL
 = (GPIO->P[3].MODEL & ~
_GPIO_P_MODEL_MODE6_MASK
| 
GPIO_P_MODEL_MODE6_PUSHPULL
;

64 
GPIO
->
P
[3].
MODEL
 = (GPIO->P[3].MODEL & ~
_GPIO_P_MODEL_MODE7_MASK
| 
GPIO_P_MODEL_MODE7_PUSHPULL
;

67 
GPIO
->
ROUTE
 = GPIO->ROUTE | 
GPIO_ROUTE_TCLKPEN
 | 
GPIO_ROUTE_TD0PEN
 | 
GPIO_ROUTE_TD1PEN


68 | 
GPIO_ROUTE_TD2PEN
 | 
GPIO_ROUTE_TD3PEN


69 | 
GPIO_ROUTE_ETMLOCATION_LOC0
;

70 
	}
}

79 
	$BSP_TSwoSup
()

82 
CMU
->
HFPERCLKEN0
 |
CMU_HFPERCLKEN0_GPIO
;

85 
GPIO
->
ROUTE
 |
GPIO_ROUTE_SWOPEN
;

88 
GPIO
->
ROUTE
 = (GPIO->ROUTE & ~(
_GPIO_ROUTE_SWLOCATION_MASK
)| 
BSP_TRACE_SWO_LOCATION
;

91 
	`TRACE_ENABLE_PINS
();

94 
CMU
->
OSCENCMD
 = 
CMU_OSCENCMD_AUXHFRCOEN
;

97 !(
CMU
->
STATUS
 & 
CMU_STATUS_AUXHFRCORDY
)) ;

100 
CeDebug
->
DEMCR
 |
CeDebug_DEMCR_TRCENA_Msk
;

103 
DWT
->
CTRL
 = 0x400113FF;

106 
TPI
->
ACPR
 = 0xf;

109 
TPI
->
SPPR
 = 2;

112 
ITM
->
LAR
 = 0xC5ACCE55;

113 
ITM
->
TCR
 = 0x10009;

114 
	}
}

123 
bo
 
	$BSP_TProfSup
()

125 vީ
ut32_t
 *
urDa
 = (ut32_*
USER_PAGE
;

128 i(*
urDa
 == 0x00000000UL)

130  
l
;

134 
	`BSP_TSwoSup
();

135  
ue
;

137 
	}
}

	@C:\Users\Alexander\AppData\Roaming\energymicro\kits\common\drivers\segmentlcd.c

35 
	~<dio.h
>

36 
	~<rg.h
>

37 
	~<dlib.h
>

38 
	~<dbo.h
>

39 
	~"em_devi.h
"

40 
	~"em_cmu.h
"

41 
	~"em_gpio.h
"

43 
	~"gmcd.h
"

69 
ut8_t
 
	mcom
[14];

70 
ut8_t
 
	mb
[14];

71 } 
	tCHAR_TyDef
;

79 
ut8_t
 
	mcom
[7];

80 
ut8_t
 
	mb
[7];

81 } 
	tNUMBER_TyDef
;

88 
ut8_t
 
	mcom
[5];

89 
ut8_t
 
	mb
[5];

90 } 
	tEM_TyDef
;

97 
ut8_t
 
	mcom
[8];

98 
ut8_t
 
	mb
[8];

99 } 
	tARING_TyDef
;

106 
ut8_t
 
	mcom
[4];

107 
ut8_t
 
	mb
[4];

108 } 
	tBATTERY_TyDef
;

115 
CHAR_TyDef
 
	mText
[7];

116 
NUMBER_TyDef
 
	mNumb
[4];

117 
EM_TyDef
 
	mEMode
;

118 
ARING_TyDef
 
	mARg
;

119 
BATTERY_TyDef
 
	mBry
;

120 } 
	tMCU_DISPLAY
;

125 cڡ 
MCU_DISPLAY
 
	gEFM_Diy
 = 
EFM_DISPLAY_DEF
;

134 cڡ 
ut16_t
 
	gEFM_Ahab
[] =

241 cڡ 
ut16_t
 
	gEFM_Numbs
[] =

264 cڡ 
ut16_t
 
	gsignIndex
 = (
EFM_Numbs
)/(uint16_t) - 1 ;

266 cڡ 
LCD_In_TyDef
 
	glcdIn
 = 
LCD_INIT_DEF
;

273 
	$SegmtLCD_AOff
()

276 
	`LCD_ALL_SEGMENTS_OFF
();

277 
	}
}

283 
	$SegmtLCD_AOn
()

285 
	`LCD_ALL_SEGMENTS_ON
();

286 
	}
}

292 
	$SegmtLCD_AhaNumbOff
()

294 
	`LCD_ALPHA_NUMBER_OFF
();

296 
	}
}

304 
	$SegmtLCD_ARg
(
um
, 

)

306 
ut32_t
 
com
, 
b
;

308 
com
 = 
EFM_Diy
.
ARg
.com[
um
];

309 
b
 = 
EFM_Diy
.
ARg
.b[
um
];

311 i(

)

313 
	`LCD_SegmtS
(
com
, 
b
, 
ue
);

317 
	`LCD_SegmtS
(
com
, 
b
, 
l
);

319 
	}
}

326 
	$SegmtLCD_Bry
(
bryLev
)

328 
ut32_t
 
com
, 
b
;

329 
i
, 

;

331 
i
 = 0; i < 4; i++)

333 i(
i
 < 
bryLev
)

335 

 = 1;

339 

 = 0;

341 
com
 = 
EFM_Diy
.
Bry
.com[
i
];

342 
b
 = 
EFM_Diy
.
Bry
.b[
i
];

344 i(

)

346 
	`LCD_SegmtS
(
com
, 
b
, 
ue
);

350 
	`LCD_SegmtS
(
com
, 
b
, 
l
);

353 
	}
}

359 
	$SegmtLCD_Dib
()

362 
	`LCD_Eb
(
l
);

365 
	`LCD_SyncBusyDay
(
LCD_SYNCBUSY_CTRL
);

368 
	`CMU_ClockEb
(
cmuClock_LCD
, 
l
);

371 
CMU
->
LCDCTRL
 = 0;

372 
	}
}

380 
	$SegmtLCD_ErgyMode
(
em
, 

)

382 
ut32_t
 
com
, 
b
;

384 
com
 = 
EFM_Diy
.
EMode
.com[
em
];

385 
b
 = 
EFM_Diy
.
EMode
.b[
em
];

387 i(

)

389 
	`LCD_SegmtS
(
com
, 
b
, 
ue
);

393 
	`LCD_SegmtS
(
com
, 
b
, 
l
);

395 
	}
}

402 
	$SegmtLCD_In
(
bo
 
uBoo
)

406 
	`CMU_ClockEb
(
cmuClock_CORELE
, 
ue
);

409 
	`CMU_ClockSeS
(
cmuClock_LFA
, 
cmuSe_LFRCO
);

412 
	`CMU_ClockDivS
(
cmuClock_LCDe
, 
LCD_CMU_CLK_PRE
);

415 
	`CMU_LCDClkFDIVS
(
LCD_CMU_CLK_DIV
);

418 
	`CMU_ClockEb
(
cmuClock_LCD
, 
ue
);

420 
	`LCD_DISPLAY_ENABLE
();

423 
	`LCD_IDib
(0xFFFFFFFF);

426 
	`LCD_In
(&
lcdIn
);

429 
	`LCD_SEGMENTS_ENABLE
();

432 i(
uBoo
)

434 
	`LCD_VBooS
(
LCD_BOOST_LEVEL
);

435 
	`LCD_VLCDSe
(
lcdVLCDSVExtBoo
);

436 
CMU
->
LCDCTRL
 |
CMU_LCDCTRL_VBOOSTEN
;

440 
	`SegmtLCD_AOff
();

442 
	`LCD_SyncBusyDay
(0xFFFFFFFF);

443 
	}
}

452 
	$SegmtLCD_LowHex

ut32_t
 
num
 )

454 
i
;

455 
r
[7];

456 
ut32_t
 
nibb
;

458 
	`SegmtLCD_Symb
(
LCD_SYMBOL_MINUS
, 0);

460  
i
=6; i>=0; i-- )

462 
nibb
 = 
num
 & 0xF;

464 i
nibb
 < 10 )

465 
r
[
i
] = 
nibb
 + '0';

466 i
nibb
 == 11 )

467 
r
[
i
] = 'b';

468 i
nibb
 == 13 )

469 
r
[
i
] = 'd';

471 
r
[
i
] = (
nibb
 - 10) + 'A';

473 
num
 >>= 4;

476 
	`SegmtLCD_Wre
(
r
);

477 
	}
}

483 
	$SegmtLCD_LowNumb

num
 )

485 
i
;

486 
r
[7];

488 
	`SegmtLCD_Symb
(
LCD_SYMBOL_MINUS
, 0);

490 i
num
 > 9999999 ) || (um < -9999999 ) )

492 
	`SegmtLCD_Wre
("Ovrflow");

496 i
num
 < 0 )

498 
	`SegmtLCD_Symb
(
LCD_SYMBOL_MINUS
, 1);

499 
num
 = -num;

502  
i
=6; i>=0; i-- )

504 i
i
 < 6 ) && ( 
num
 == 0 ) )

506 
r
[
i
] = ' ';

510 
r
[
i
] = (
num
 % 10) + '0';

511 
num
 /= 10;

515 
	`SegmtLCD_Wre
(
r
);

516 
	}
}

523 
	$SegmtLCD_Numb
(
vue
)

525 
i
, 
com
, 
b
, 
dig
, 
div
, 
g
;

526 
ut16_t
 
bn
;

527 
ut16_t
 
num
;

530 i(
vue
 >= 9999)

532 
vue
 = 9999;

534 i(
vue
 <= -1000)

536 
vue
 = -999;

538 i(
vue
 < 0)

540 
vue
 = 
	`abs
(value);

541 
g
 = 1;

545 
g
 = 0;

549 
	`LCD_SyncBusyDay
(0xFFFFFFFF);

552 
	`LCD_FezeEb
(
ue
);

555 
	`SegmtLCD_NumbOff
();

558 
div
 = 1;

559 
dig
 = 0; digit < 4; digit++)

561 
num
 = (
vue
 / 
div
) % 10;

562 i((
g
 =1&& (
dig
 =3)
num
 = 
signIndex
;

564 
bn
 = 
EFM_Numbs
[
num
];

565 
i
 = 0; i < 7; i++)

567 
b
 = 
EFM_Diy
.
Numb
[
dig
].b[
i
];

568 
com
 = 
EFM_Diy
.
Numb
[
dig
].com[
i
];

569 i(
bn
 & (1 << 
i
))

571 
	`LCD_SegmtS
(
com
, 
b
, 
ue
);

574 
div
 = div * 10;

577 
	`LCD_FezeEb
(
l
);

578 
	}
}

584 
	$SegmtLCD_NumbOff
()

587 
	`LCD_NUMBER_OFF
();

589 
	}
}

597 
	$SegmtLCD_Symb
(
lcdSymb
 
s
, 

)

599 
com
 = 0;

600 
b
 = 0;

602 
s
)

604 
LCD_SYMBOL_GECKO
:

605 
com
 = 
LCD_SYMBOL_GECKO_COM
;

606 
b
 = 
LCD_SYMBOL_GECKO_SEG
;

608 
LCD_SYMBOL_ANT
:

609 
com
 = 
LCD_SYMBOL_ANT_COM
;

610 
b
 = 
LCD_SYMBOL_ANT_SEG
;

612 
LCD_SYMBOL_PAD0
:

613 
com
 = 
LCD_SYMBOL_PAD0_COM
;

614 
b
 = 
LCD_SYMBOL_PAD0_SEG
;

616 
LCD_SYMBOL_PAD1
:

617 
com
 = 
LCD_SYMBOL_PAD1_COM
;

618 
b
 = 
LCD_SYMBOL_PAD1_SEG
;

620 
LCD_SYMBOL_EFM32
:

621 
com
 = 
LCD_SYMBOL_EFM32_COM
;

622 
b
 = 
LCD_SYMBOL_EFM32_SEG
;

624 
LCD_SYMBOL_MINUS
:

625 
com
 = 
LCD_SYMBOL_MINUS_COM
;

626 
b
 = 
LCD_SYMBOL_MINUS_SEG
;

628 
LCD_SYMBOL_COL3
:

629 
com
 = 
LCD_SYMBOL_COL3_COM
;

630 
b
 = 
LCD_SYMBOL_COL3_SEG
;

632 
LCD_SYMBOL_COL5
:

633 
com
 = 
LCD_SYMBOL_COL5_COM
;

634 
b
 = 
LCD_SYMBOL_COL5_SEG
;

636 
LCD_SYMBOL_COL10
:

637 
com
 = 
LCD_SYMBOL_COL10_COM
;

638 
b
 = 
LCD_SYMBOL_COL10_SEG
;

640 #ifde
LCD_SYMBOL_DEGC_SEG


641 
LCD_SYMBOL_DEGC
:

642 
com
 = 
LCD_SYMBOL_DEGC_COM
;

643 
b
 = 
LCD_SYMBOL_DEGC_SEG
;

646 #ifde
LCD_SYMBOL_DEGF_SEG


647 
LCD_SYMBOL_DEGF
:

648 
com
 = 
LCD_SYMBOL_DEGF_COM
;

649 
b
 = 
LCD_SYMBOL_DEGF_SEG
;

652 #ifde
LCD_SYMBOL_DP2_SEG


653 
LCD_SYMBOL_DP2
:

654 
com
 = 
LCD_SYMBOL_DP2_COM
;

655 
b
 = 
LCD_SYMBOL_DP2_SEG
;

658 #ifde
LCD_SYMBOL_DP3_SEG


659 
LCD_SYMBOL_DP3
:

660 
com
 = 
LCD_SYMBOL_DP3_COM
;

661 
b
 = 
LCD_SYMBOL_DP3_SEG
;

664 #ifde
LCD_SYMBOL_DP4_SEG


665 
LCD_SYMBOL_DP4
:

666 
com
 = 
LCD_SYMBOL_DP4_COM
;

667 
b
 = 
LCD_SYMBOL_DP4_SEG
;

670 #ifde
LCD_SYMBOL_DP5_SEG


671 
LCD_SYMBOL_DP5
:

672 
com
 = 
LCD_SYMBOL_DP5_COM
;

673 
b
 = 
LCD_SYMBOL_DP5_SEG
;

676 
LCD_SYMBOL_DP6
:

677 
com
 = 
LCD_SYMBOL_DP6_COM
;

678 
b
 = 
LCD_SYMBOL_DP6_SEG
;

680 
LCD_SYMBOL_DP10
:

681 
com
 = 
LCD_SYMBOL_DP10_COM
;

682 
b
 = 
LCD_SYMBOL_DP10_SEG
;

684 #ifde
LCD_SYMBOL_AM_SEG


685 
LCD_SYMBOL_AM
:

686 
com
 = 
LCD_SYMBOL_AM_COM
;

687 
b
 = 
LCD_SYMBOL_AM_SEG
;

690 #ifde
LCD_SYMBOL_PM_SEG


691 
LCD_SYMBOL_PM
:

692 
com
 = 
LCD_SYMBOL_PM_COM
;

693 
b
 = 
LCD_SYMBOL_PM_SEG
;

696 #ifde
LCD_SYMBOL_MICROAMP_SEG


697 
LCD_SYMBOL_MICROAMP
:

698 
com
 = 
LCD_SYMBOL_MICROAMP_COM
;

699 
b
 = 
LCD_SYMBOL_MICROAMP_SEG
;

702 #ifde
LCD_SYMBOL_MILLIAMP_SEG


703 
LCD_SYMBOL_MILLIAMP
:

704 
com
 = 
LCD_SYMBOL_MILLIAMP_COM
;

705 
b
 = 
LCD_SYMBOL_MILLIAMP_SEG
;

710 i(

)

712 
	`LCD_SegmtS
(
com
, 
b
, 
ue
);

716 
	`LCD_SegmtS
(
com
, 
b
, 
l
);

718 
	}
}

725 
	$SegmtLCD_UnsigdHex
(
ut16_t
 
vue
)

727 
num
, 
i
, 
com
, 
b
, 
dig
;

728 
ut16_t
 
bn
;

731 i(
vue
 >= 0xffff)

733 
vue
 = 0xffff;

737 
	`LCD_SyncBusyDay
(0xFFFFFFFF);

740 
	`LCD_FezeEb
(
ue
);

743 
	`SegmtLCD_NumbOff
();

745 
dig
 = 0; digit < 4; digit++)

747 
num
 = (
vue
 >> (4 * 
dig
)) & 0x0f;

748 
bn
 = 
EFM_Numbs
[
num
];

749 
i
 = 0; i < 7; i++)

751 
b
 = 
EFM_Diy
.
Numb
[
dig
].b[
i
];

752 
com
 = 
EFM_Diy
.
Numb
[
dig
].com[
i
];

753 i(
bn
 & (1 << 
i
))

755 
	`LCD_SegmtS
(
com
, 
b
, 
ue
);

761 
	`LCD_FezeEb
(
l
);

762 
	}
}

769 
	$SegmtLCD_Wre
(*
rg
)

771 
da
, 
ngth
, 
dex
;

772 
ut16_t
 
bfld
;

773 
ut32_t
 
com
, 
b
;

774 
i
;

776 
ngth
 = 
	`
(
rg
);

777 
dex
 = 0;

780 
	`LCD_SyncBusyDay
(0xFFFFFFFF);

783 
	`LCD_FezeEb
(
ue
);

786 
	`SegmtLCD_AhaNumbOff
();

789 
dex
 = 0; index < 7; index++)

791 i(
dex
 < 
ngth
)

793 
da
 = (*
rg
;

797 
da
 = 0x20;

800 
da
 = data - 0x20;

802 
bfld
 = 
EFM_Ahab
[
da
];

804 
i
 = 0; i < 14; i++)

806 
b
 = 
EFM_Diy
.
Text
[
dex
].b[
i
];

807 
com
 = 
EFM_Diy
.
Text
[
dex
].com[
i
];

809 i(
bfld
 & (1 << 
i
))

812 
	`LCD_SegmtS
(
com
, 
b
, 
ue
);

815 
rg
++;

818 
	`LCD_FezeEb
(
l
);

819 
	}
}

	@C:\Users\Alexander\AppData\Roaming\energymicro\kits\common\drivers\segmentlcd.h

35 #ide
__SEGMENTLCD_H


36 
	#__SEGMENTLCD_H


	)

38 
	~<dt.h
>

39 
	~<dbo.h
>

41 
	~"gmcdcfig.h
"

53 #ifde
__lulus


58 
SegmtLCD_AOff
();

59 
SegmtLCD_AOn
();

60 
SegmtLCD_AhaNumbOff
();

61 
SegmtLCD_ARg
(
um
, 

);

62 
SegmtLCD_Bry
(
bryLev
);

63 
SegmtLCD_Dib
();

64 
SegmtLCD_ErgyMode
(
em
, 

);

65 
SegmtLCD_In
(
bo
 
uBoo
);

66 
SegmtLCD_LowHex
(
ut32_t
 
num
);

67 
SegmtLCD_LowNumb
(
num
);

68 
SegmtLCD_Numb
(
vue
);

69 
SegmtLCD_NumbOff
();

70 
SegmtLCD_Symb
(
lcdSymb
 
s
, 

);

71 
SegmtLCD_UnsigdHex
(
ut16_t
 
vue
);

72 
SegmtLCD_Wre
(*
rg
);

74 #ifde
__lulus


	@
1
.
0
41
3690
C:\Users\Alexander\AppData\Roaming\energymicro\Device\EnergyMicro\EFM32GG\Source\GCC\startup_efm32gg.S
C:\Users\Alexander\AppData\Roaming\energymicro\Device\EnergyMicro\EFM32GG\Source\system_efm32gg.c
C:\Users\Alexander\AppData\Roaming\energymicro\emlib\src\em_assert.c
C:\Users\Alexander\AppData\Roaming\energymicro\emlib\src\em_cmu.c
C:\Users\Alexander\AppData\Roaming\energymicro\emlib\src\em_ebi.c
C:\Users\Alexander\AppData\Roaming\energymicro\emlib\src\em_emu.c
C:\Users\Alexander\AppData\Roaming\energymicro\emlib\src\em_gpio.c
C:\Users\Alexander\AppData\Roaming\energymicro\emlib\src\em_lcd.c
C:\Users\Alexander\AppData\Roaming\energymicro\emlib\src\em_letimer.c
C:\Users\Alexander\AppData\Roaming\energymicro\emlib\src\em_pcnt.c
C:\Users\Alexander\AppData\Roaming\energymicro\emlib\src\em_rtc.c
C:\Users\Alexander\AppData\Roaming\energymicro\emlib\src\em_system.c
C:\Users\Alexander\AppData\Roaming\energymicro\emlib\src\em_usart.c
C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\ADXL345.c
C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\ADXL345.h
C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\activity_app.c
C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\activity_app.h
C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\blink.c
C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\buttons.c
C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\buttons.h
C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\globals.h
C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\main_screen_app.c
C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\main_screen_app.h
C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\pedometer.c
C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\pomodoro_app.c
C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\pomodoro_app.h
C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\setup_alarm_app.c
C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\setup_time_app.c
C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\setup_time_app.h
C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\state_machine.c
C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\state_machine.h
C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\time_management.c
C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\time_management.h
C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\variables.c
C:\Users\Alexander\AppData\Roaming\energymicro\kits\EFM32GG_STK3700\my_projects\LSM_watch\variables.h
C:\Users\Alexander\AppData\Roaming\energymicro\kits\common\bsp\bsp_bcc.c
C:\Users\Alexander\AppData\Roaming\energymicro\kits\common\bsp\bsp_stk.c
C:\Users\Alexander\AppData\Roaming\energymicro\kits\common\bsp\bsp_stk_leds.c
C:\Users\Alexander\AppData\Roaming\energymicro\kits\common\bsp\bsp_trace.c
C:\Users\Alexander\AppData\Roaming\energymicro\kits\common\drivers\segmentlcd.c
C:\Users\Alexander\AppData\Roaming\energymicro\kits\common\drivers\segmentlcd.h
